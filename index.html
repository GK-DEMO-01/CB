<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RPChat - AI Role Playing Chatbot</title>
<style>
  :root {
    --bg-primary: #0f0f1a;
    --bg-secondary: #1a1a2e;
    --bg-tertiary: #252540;
    --accent: #7c5cff;
    --accent-hover: #9a7fff;
    --accent-dim: rgba(124, 92, 255, 0.15);
    --text-primary: #e8e8f0;
    --text-secondary: #a0a0b8;
    --text-muted: #6a6a80;
    --border: #2e2e48;
    --user-bubble: #2a2a50;
    --ai-bubble: #1e1e38;
    --danger: #ff4466;
    --success: #44cc88;
    --warning: #ffaa33;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100vh;
    overflow: hidden;
  }

  .app { display: flex; height: 100vh; }

  /* ─── Sidebar ─── */
  .sidebar {
    width: 320px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: transform 0.3s;
  }
  .sidebar.collapsed { transform: translateX(-320px); position: absolute; z-index: 100; height: 100%; }

  .sidebar-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .sidebar-header h2 { font-size: 18px; font-weight: 600; color: var(--accent); }

  .sidebar-header-actions { display: flex; gap: 6px; align-items: center; }

  .settings-btn {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    color: var(--text-secondary);
    width: 32px; height: 32px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
  }
  .settings-btn:hover { color: var(--text-primary); border-color: var(--accent); }

  .sidebar-content { flex: 1; overflow-y: auto; padding: 16px; }

  .sidebar-section { margin-bottom: 20px; }
  .sidebar-section h3 {
    font-size: 11px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1.2px; color: var(--text-muted); margin-bottom: 10px;
  }

  /* ─── Character Cards ─── */
  .char-card {
    background: var(--bg-tertiary); border: 1px solid var(--border);
    border-radius: 12px; padding: 14px; margin-bottom: 8px;
    cursor: pointer; transition: all 0.2s; position: relative;
  }
  .char-card:hover { border-color: var(--accent); background: var(--accent-dim); }
  .char-card.active { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent); }

  .char-card-top { display: flex; align-items: center; gap: 10px; }

  .char-avatar {
    width: 42px; height: 42px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; flex-shrink: 0; overflow: hidden;
  }
  .char-avatar img { width: 100%; height: 100%; object-fit: cover; }

  .char-info h4 { font-size: 14px; font-weight: 600; margin-bottom: 2px; }
  .char-info p {
    font-size: 12px; color: var(--text-secondary); line-height: 1.3;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
  }

  .char-actions {
    position: absolute; top: 10px; right: 10px;
    display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s;
  }
  .char-card:hover .char-actions { opacity: 1; }

  .char-action-btn {
    width: 26px; height: 26px; border-radius: 6px; border: none;
    background: var(--bg-secondary); color: var(--text-secondary);
    cursor: pointer; font-size: 13px;
    display: flex; align-items: center; justify-content: center;
  }
  .char-action-btn:hover { color: var(--text-primary); background: var(--border); }
  .char-action-btn.delete:hover { color: var(--danger); }

  /* ─── Chat History List ─── */
  .chat-history { margin-top: 8px; }
  .chat-history-header {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 8px;
  }
  .chat-item {
    padding: 8px 12px; border-radius: 8px; cursor: pointer;
    font-size: 13px; color: var(--text-secondary); transition: all 0.2s;
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 4px; position: relative;
  }
  .chat-item:hover { background: var(--bg-tertiary); color: var(--text-primary); }
  .chat-item.active { background: var(--accent-dim); color: var(--accent); font-weight: 600; }
  .chat-item-title {
    flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .chat-item-delete {
    background: none; border: none; color: var(--text-muted); cursor: pointer;
    font-size: 12px; padding: 2px 4px; opacity: 0; transition: opacity 0.2s;
  }
  .chat-item:hover .chat-item-delete { opacity: 1; }
  .chat-item-delete:hover { color: var(--danger); }

  /* ─── Buttons ─── */
  .btn {
    padding: 10px 16px; border-radius: 8px; border: none;
    font-size: 13px; font-weight: 600; cursor: pointer;
    transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px;
  }
  .btn-primary { background: var(--accent); color: white; }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
  .btn-secondary:hover { border-color: var(--accent); }
  .btn-danger { background: rgba(255, 68, 102, 0.15); color: var(--danger); }
  .btn-danger:hover { background: rgba(255, 68, 102, 0.25); }
  .btn-block { width: 100%; justify-content: center; }
  .btn-sm { padding: 6px 12px; font-size: 12px; }

  /* ─── Main Chat ─── */
  .main { flex: 1; display: flex; flex-direction: column; min-width: 0; }

  .chat-header {
    padding: 16px 24px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 14px; background: var(--bg-secondary);
  }
  .chat-header .toggle-sidebar {
    background: none; border: none; color: var(--text-secondary);
    font-size: 20px; cursor: pointer; padding: 4px;
  }
  .chat-header-info { flex: 1; }
  .chat-header-info h3 { font-size: 16px; font-weight: 600; }
  .chat-header-info p { font-size: 12px; color: var(--text-secondary); }
  .header-actions { display: flex; gap: 8px; align-items: center; }
  .model-select {
    background: var(--bg-tertiary); border: 1px solid var(--border);
    color: var(--text-primary); padding: 8px 12px; border-radius: 8px;
    font-size: 13px; cursor: pointer; max-width: 220px;
  }
  .model-select:focus { outline: none; border-color: var(--accent); }

  /* ─── Messages ─── */
  .messages {
    flex: 1; overflow-y: auto; padding: 24px; padding-right: 16px;
    display: flex; flex-direction: column; gap: 16px;
    min-height: 0;
    scrollbar-width: thin;
    scrollbar-color: rgba(124,92,255,0.4) rgba(255,255,255,0.05);
  }
  .messages::-webkit-scrollbar { width: 8px; }
  .messages::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
  .messages::-webkit-scrollbar-thumb { background: rgba(124,92,255,0.4); border-radius: 4px; }
  .messages::-webkit-scrollbar-thumb:hover { background: rgba(124,92,255,0.6); }
  .message {
    max-width: 75%; padding: 14px 18px; border-radius: 16px;
    line-height: 1.6; font-size: 14px;
    word-wrap: break-word; position: relative;
  }
  .message.new { animation: fadeIn 0.3s ease; }
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(8px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .message.user {
    background: var(--user-bubble); align-self: flex-end; border-bottom-right-radius: 4px;
  }
  .message.assistant {
    background: var(--ai-bubble); border: 1px solid var(--border);
    align-self: flex-start; border-bottom-left-radius: 4px;
  }
  .message .sender {
    font-size: 11px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.8px; margin-bottom: 6px; color: var(--accent);
  }
  .message.user .sender { color: var(--text-muted); }

  /* ─── RP Formatting ─── */
  .rp-action { color: #b0b0cc; font-style: italic; opacity: 0.85; }
  .rp-bold { font-weight: 700; color: var(--text-primary); }
  .rp-dialogue { color: var(--text-primary); font-weight: 400; font-style: normal; }
  .rp-ooc { font-size: 12px; color: var(--text-muted); font-style: italic; }
  .rp-instruction { color: rgba(124,92,255,0.7); font-size: 12px; font-style: italic; }

  /* ─── Message Actions (edit) ─── */
  .message-actions {
    position: absolute; top: 8px; right: 8px;
    display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s;
  }
  .message:hover .message-actions { opacity: 1; }
  .msg-action-btn {
    width: 24px; height: 24px; border-radius: 6px; border: none;
    background: var(--bg-tertiary); color: var(--text-secondary);
    cursor: pointer; font-size: 12px;
    display: flex; align-items: center; justify-content: center;
  }
  .msg-action-btn:hover { color: var(--text-primary); background: var(--border); }

  .edit-area textarea {
    width: 100%; background: var(--bg-tertiary); border: 1px solid var(--accent);
    color: var(--text-primary); padding: 10px; border-radius: 8px;
    font-size: 14px; font-family: inherit; resize: vertical;
    min-height: 60px; line-height: 1.5;
  }
  .edit-area textarea:focus { outline: none; }
  .edit-actions { display: flex; gap: 6px; margin-top: 8px; justify-content: flex-end; }

  /* ─── Typing Indicator ─── */
  .typing-indicator {
    align-self: flex-start; padding: 14px 18px;
    background: var(--ai-bubble); border: 1px solid var(--border);
    border-radius: 16px; border-bottom-left-radius: 4px; display: none;
  }
  .typing-indicator.active { display: flex; gap: 4px; align-items: center; }
  .typing-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--text-muted); animation: typingBounce 1.4s infinite;
  }
  .typing-dot:nth-child(2) { animation-delay: 0.2s; }
  .typing-dot:nth-child(3) { animation-delay: 0.4s; }
  @keyframes typingBounce {
    0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
    30% { transform: translateY(-6px); opacity: 1; }
  }

  /* ─── Input Area ─── */
  .input-area { padding: 16px 24px; border-top: 1px solid var(--border); background: var(--bg-secondary); }
  .input-wrapper { display: flex; gap: 10px; align-items: flex-end; }
  .input-wrapper textarea {
    flex: 1; background: var(--bg-tertiary); border: 1px solid var(--border);
    color: var(--text-primary); padding: 12px 16px; border-radius: 12px;
    font-size: 14px; font-family: inherit; resize: none;
    min-height: 46px; max-height: 150px; line-height: 1.5;
  }
  .input-wrapper textarea:focus { outline: none; border-color: var(--accent); }
  .input-wrapper textarea::placeholder { color: var(--text-muted); }
  .send-btn {
    width: 46px; height: 46px; border-radius: 12px; border: none;
    background: var(--accent); color: white; font-size: 18px;
    cursor: pointer; flex-shrink: 0; transition: background 0.2s;
  }
  .send-btn:hover { background: var(--accent-hover); }
  .send-btn:disabled { opacity: 0.4; cursor: not-allowed; }

  /* ─── Welcome ─── */
  .welcome {
    flex: 1; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    text-align: center; padding: 40px; gap: 16px;
  }
  .welcome h2 { font-size: 28px; color: var(--accent); }
  .welcome p { color: var(--text-secondary); max-width: 500px; line-height: 1.6; }

  /* ─── Modal ─── */
  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px); display: none;
    align-items: center; justify-content: center; z-index: 1000;
  }
  .modal-overlay.active { display: flex; }
  .modal {
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 16px; width: 520px; max-width: 92vw;
    max-height: 88vh; overflow: hidden; padding: 0;
    animation: modalIn 0.25s ease;
    display: flex; flex-direction: column;
  }
  .modal-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 28px 28px 16px; background: var(--bg-secondary);
    border-radius: 16px 16px 0 0; border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .modal-header h3 { margin-bottom: 0; }
  .modal-close-btn {
    width: 36px; height: 36px; border-radius: 8px; border: none;
    background: var(--bg-tertiary); color: var(--text-secondary);
    font-size: 18px; cursor: pointer; display: flex; align-items: center;
    justify-content: center; flex-shrink: 0; transition: all 0.2s;
    -webkit-tap-highlight-color: transparent;
  }
  .modal-close-btn:hover { color: var(--text-primary); background: var(--border); }
  .modal-body { padding: 0 28px 28px; overflow-y: auto; flex: 1; min-height: 0; -webkit-overflow-scrolling: touch; }
  @keyframes modalIn {
    from { opacity: 0; transform: scale(0.95) translateY(10px); }
    to { opacity: 1; transform: scale(1) translateY(0); }
  }
  .modal h3 { font-size: 18px; margin-bottom: 20px; color: var(--text-primary); }
  .form-group { margin-bottom: 16px; }
  .form-group label {
    display: block; font-size: 12px; font-weight: 600;
    text-transform: uppercase; letter-spacing: 0.8px;
    color: var(--text-secondary); margin-bottom: 6px;
  }
  .form-group input, .form-group textarea, .form-group select {
    width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border);
    color: var(--text-primary); padding: 10px 14px; border-radius: 8px;
    font-size: 14px; font-family: inherit;
  }
  .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
    outline: none; border-color: var(--accent);
  }
  .form-group textarea { resize: vertical; min-height: 80px; }
  .form-hint { font-size: 11px; color: var(--text-muted); margin-top: 4px; }
  .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 24px; }

  /* ─── Avatar Tabs ─── */
  .avatar-tabs { display: flex; gap: 0; margin-bottom: 10px; }
  .avatar-tab {
    flex: 1; padding: 8px; text-align: center; font-size: 12px; font-weight: 600;
    color: var(--text-muted); background: var(--bg-tertiary); border: 1px solid var(--border);
    cursor: pointer; transition: all 0.2s;
  }
  .avatar-tab:first-child { border-radius: 8px 0 0 8px; }
  .avatar-tab:last-child { border-radius: 0 8px 8px 0; }
  .avatar-tab.active { color: var(--accent); background: var(--accent-dim); border-color: var(--accent); }
  .avatar-tab-content { display: none; }
  .avatar-tab-content.active { display: block; }

  .emoji-picker { display: flex; gap: 6px; flex-wrap: wrap; }
  .emoji-option {
    width: 40px; height: 40px; border-radius: 8px; border: 2px solid transparent;
    background: var(--bg-tertiary); font-size: 20px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; transition: all 0.2s;
  }
  .emoji-option:hover { border-color: var(--border); }
  .emoji-option.selected { border-color: var(--accent); background: var(--accent-dim); }

  .color-picker { display: flex; gap: 6px; flex-wrap: wrap; }
  .color-option {
    width: 32px; height: 32px; border-radius: 50%;
    border: 2px solid transparent; cursor: pointer; transition: all 0.2s;
  }
  .color-option:hover { transform: scale(1.1); }
  .color-option.selected { border-color: white; box-shadow: 0 0 0 2px var(--accent); }

  /* ─── Avatar Upload ─── */
  .avatar-upload-area {
    display: flex; flex-direction: column; align-items: center; gap: 12px; padding: 16px;
  }
  .avatar-upload-preview {
    width: 80px; height: 80px; border-radius: 50%; background: var(--bg-tertiary);
    border: 2px dashed var(--border); display: flex; align-items: center;
    justify-content: center; overflow: hidden; font-size: 28px; color: var(--text-muted);
  }
  .avatar-upload-preview img { width: 100%; height: 100%; object-fit: cover; }
  .avatar-upload-preview.has-image { border-style: solid; border-color: var(--accent); }
  .avatar-file-input { display: none; }

  /* ─── AI Generate ─── */
  .ai-gen-section {
    background: linear-gradient(135deg, rgba(124,92,255,0.08), rgba(92,184,255,0.08));
    border: 1px dashed var(--accent); border-radius: 12px; padding: 16px; margin-bottom: 20px;
  }
  .ai-gen-section h4 {
    font-size: 13px; font-weight: 700; color: var(--accent);
    margin-bottom: 10px; display: flex; align-items: center; gap: 6px;
  }
  .ai-gen-row { display: flex; gap: 8px; }
  .ai-gen-row input {
    flex: 1; background: var(--bg-tertiary); border: 1px solid var(--border);
    color: var(--text-primary); padding: 10px 14px; border-radius: 8px;
    font-size: 14px; font-family: inherit;
  }
  .ai-gen-row input:focus { outline: none; border-color: var(--accent); }
  .ai-gen-row input::placeholder { color: var(--text-muted); }
  .ai-gen-status { font-size: 12px; color: var(--text-secondary); margin-top: 8px; min-height: 18px; }
  .ai-gen-status.generating { color: var(--accent); }
  .ai-gen-status.error { color: var(--danger); }

  @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
  .btn-generating {
    background: linear-gradient(90deg, var(--accent), var(--accent-hover), var(--accent));
    background-size: 200% 100%; animation: shimmer 1.5s infinite; pointer-events: none;
  }

  /* ─── Auth Screen ─── */
  .auth-screen { display: flex; align-items: center; justify-content: center; height: 100vh; padding: 40px; }
  .auth-card {
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 20px; padding: 48px; text-align: center; max-width: 460px; width: 100%;
  }
  .auth-card h1 { font-size: 32px; color: var(--accent); margin-bottom: 8px; }
  .auth-card .subtitle { color: var(--text-secondary); margin-bottom: 32px; line-height: 1.5; }
  .auth-card .btn { margin-top: 16px; font-size: 15px; padding: 14px 28px; }
  .auth-divider {
    display: flex; align-items: center; gap: 12px; margin: 24px 0;
    color: var(--text-muted); font-size: 12px;
  }
  .auth-divider::before, .auth-divider::after { content: ''; flex: 1; height: 1px; background: var(--border); }
  .api-key-input { display: flex; gap: 8px; }
  .api-key-input input { flex: 1; }
  .auth-status { margin-top: 16px; font-size: 13px; padding: 10px; border-radius: 8px; display: none; }
  .auth-status.error { display: block; background: rgba(255,68,102,0.1); color: var(--danger); }
  .auth-status.success { display: block; background: rgba(68,204,136,0.1); color: var(--success); }
  .connected-badge {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 4px 10px; border-radius: 20px; font-size: 12px; font-weight: 600;
    background: rgba(68,204,136,0.1); color: var(--success);
  }
  .connected-badge::before { content: ''; width: 6px; height: 6px; border-radius: 50%; background: var(--success); }
  .disconnect-btn {
    background: none; border: none; color: var(--text-muted);
    cursor: pointer; font-size: 12px; text-decoration: underline;
  }
  .disconnect-btn:hover { color: var(--danger); }

  /* ─── Scrollbar ─── */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

  /* ─── More Button (character cards) ─── */
  .char-more-btn {
    position: absolute; top: 10px; right: 10px;
    width: 28px; height: 28px; border-radius: 6px; border: none;
    background: var(--bg-secondary); color: var(--text-secondary);
    cursor: pointer; font-size: 16px; line-height: 1;
    display: flex; align-items: center; justify-content: center;
    z-index: 2; -webkit-tap-highlight-color: transparent;
    transition: all 0.2s;
  }
  .char-more-btn:hover { color: var(--text-primary); background: var(--border); }

  /* ─── Context Menu ─── */
  .context-menu {
    position: fixed; z-index: 2000;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 10px; padding: 4px; min-width: 160px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    animation: modalIn 0.15s ease;
  }
  .context-menu-item {
    display: flex; align-items: center; gap: 8px;
    padding: 10px 14px; border-radius: 6px; border: none;
    background: none; color: var(--text-primary); width: 100%;
    font-size: 13px; cursor: pointer; text-align: left;
    font-family: inherit; -webkit-tap-highlight-color: transparent;
    transition: background 0.15s;
  }
  .context-menu-item:hover { background: var(--bg-tertiary); }
  .context-menu-item.danger { color: var(--danger); }
  .context-menu-item.danger:hover { background: rgba(255,68,102,0.1); }
  .context-menu-sep { height: 1px; background: var(--border); margin: 4px 8px; }

  /* ─── Chat Item More Button ─── */
  .chat-item-more {
    background: none; border: none; color: var(--text-muted); cursor: pointer;
    font-size: 14px; padding: 2px 4px; flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }
  .chat-item-more:hover { color: var(--text-primary); }

  /* ─── Import Button Inline ─── */
  .import-btn-inline {
    background: none; border: none; color: var(--text-muted);
    font-size: 11px; cursor: pointer; padding: 2px 6px;
    font-family: inherit; -webkit-tap-highlight-color: transparent;
  }
  .import-btn-inline:hover { color: var(--accent); }

  /* ─── Active Characters Bar ─── */
  .active-chars-bar {
    display: flex; gap: 6px; flex-wrap: wrap; align-items: center;
    padding: 6px 16px; border-bottom: 1px solid var(--border);
    background: var(--bg-secondary); min-height: 0;
  }
  .active-chars-bar:empty { display: none; }
  .active-char-chip {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 10px 3px 6px; border-radius: 20px;
    background: var(--bg-tertiary); border: 1px solid var(--border);
    font-size: 12px; color: var(--text-secondary);
  }
  .active-char-chip .chip-avatar {
    width: 18px; height: 18px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 11px; overflow: hidden;
  }
  .active-char-chip .chip-avatar img { width: 100%; height: 100%; object-fit: cover; }
  .active-char-chip.primary { border-color: var(--accent); color: var(--accent); }
  .active-char-chip .chip-remove {
    margin-left: 2px; cursor: pointer; font-size: 10px;
    color: var(--text-muted); background: none; border: none;
    padding: 0; width: 14px; height: 14px; display: flex;
    align-items: center; justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }
  .active-char-chip .chip-remove:hover { color: var(--danger); }

  /* ─── Narration Message ─── */
  .message.narration {
    background: transparent; align-self: center; text-align: center;
    max-width: 90%; font-style: italic; color: var(--text-secondary);
    border: 1px dashed var(--border); padding: 10px 18px; margin: 8px auto;
  }
  .message.narration .sender { color: var(--text-muted); font-size: 11px; }

  /* ─── System Event Message ─── */
  .message.system-event {
    background: transparent; align-self: center; text-align: center;
    max-width: 80%; color: var(--text-muted); font-size: 12px;
    padding: 6px 12px; margin: 4px auto;
  }

  /* ─── Previous Context Banner ─── */
  .context-banner {
    background: var(--accent-dim); border: 1px solid var(--accent);
    border-radius: 12px; padding: 12px 16px; margin: 8px 16px 12px;
    font-size: 13px; line-height: 1.5; color: var(--text-secondary);
  }
  .context-banner-header {
    display: flex; align-items: center; justify-content: space-between;
    cursor: pointer; user-select: none; -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .context-banner-header h4 {
    font-size: 12px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.8px; color: var(--accent); margin: 0;
  }
  .context-banner-toggle {
    background: none; border: none; color: var(--accent);
    font-size: 14px; cursor: pointer; padding: 2px 6px;
    -webkit-tap-highlight-color: transparent;
  }
  .context-banner-body { margin-top: 10px; display: none; }
  .context-banner-body.open { display: block; }
  .context-banner-body .context-summary { margin-bottom: 8px; color: var(--text-primary); }
  .context-char-memory {
    background: var(--bg-tertiary); border-radius: 8px;
    padding: 8px 12px; margin-top: 6px;
  }
  .context-char-memory h5 {
    font-size: 11px; font-weight: 700; text-transform: uppercase;
    letter-spacing: 0.6px; color: var(--text-muted); margin: 0 0 4px;
  }
  .context-banner-source {
    font-size: 11px; color: var(--text-muted); margin-top: 8px; font-style: italic;
  }

  /* ─── Generation Preset Selector ─── */
  .preset-selector {
    display: flex; gap: 8px; flex-wrap: wrap;
  }
  .preset-option {
    flex: 1; min-width: 90px; padding: 12px 10px; border-radius: 10px;
    border: 2px solid var(--border); background: var(--bg-tertiary);
    cursor: pointer; text-align: center; transition: border-color 0.2s, background 0.2s;
    -webkit-tap-highlight-color: transparent; min-height: 48px;
  }
  .preset-option:active { transform: scale(0.97); }
  .preset-option.selected {
    border-color: var(--accent); background: rgba(124,92,255,0.1);
  }
  .preset-option-title {
    font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;
  }
  .preset-option-desc {
    font-size: 11px; color: var(--text-muted); line-height: 1.3;
  }

  /* ─── Command Hint Popup ─── */
  .command-hint {
    position: absolute; bottom: 100%; left: 0; right: 0;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 10px; padding: 6px; margin-bottom: 4px;
    font-size: 13px; color: var(--text-secondary);
    display: none; z-index: 10; max-height: 240px; overflow-y: auto;
    overscroll-behavior: contain; -webkit-overflow-scrolling: touch;
    box-shadow: 0 -4px 16px rgba(0,0,0,0.25);
  }
  .command-hint.visible { display: block; }
  .command-hint-item {
    padding: 10px 12px; border-radius: 8px; cursor: pointer;
    display: flex; align-items: center; gap: 10px;
    -webkit-tap-highlight-color: transparent; min-height: 44px;
  }
  .command-hint-item:active { background: var(--bg-tertiary); }
  @media (hover: hover) { .command-hint-item:hover { background: var(--bg-tertiary); } }
  .command-hint-cmd {
    font-family: 'SF Mono', 'Menlo', monospace; font-size: 13px; font-weight: 600;
    color: var(--accent); background: rgba(124,92,255,0.12); padding: 2px 7px;
    border-radius: 5px; white-space: nowrap; flex-shrink: 0;
  }
  .command-hint-desc {
    font-size: 12px; color: var(--text-muted); line-height: 1.3;
  }
  .command-hint-empty {
    padding: 10px 12px; font-size: 12px; color: var(--text-muted); text-align: center;
    font-style: italic;
  }

  /* ─── Responsive ─── */
  @media (max-width: 768px) {
    .sidebar { position: absolute; z-index: 100; height: 100%; transform: translateX(-320px); }
    .sidebar.open { transform: translateX(0); }
    .message { max-width: 90%; }
  }
</style>
</head>
<body>

<!-- AUTH SCREEN -->
<div id="authScreen" class="auth-screen">
  <div class="auth-card">
    <h1>RPChat</h1>
    <p class="subtitle">AI-powered role-playing chatbot with customizable characters</p>
    <button class="btn btn-primary btn-block" onclick="startOAuthFlow()" style="font-size:15px;padding:14px 28px;">
      Connect with OpenRouter
    </button>
    <div class="auth-divider">or enter API key directly</div>
    <div class="api-key-input">
      <input type="password" id="apiKeyInput" placeholder="sk-or-v1-..." onkeydown="if(event.key==='Enter')saveDirectKey()">
      <button class="btn btn-secondary" onclick="saveDirectKey()">Save</button>
    </div>
    <div id="authStatus" class="auth-status"></div>
  </div>
</div>

<!-- MAIN APP -->
<div id="appScreen" class="app" style="display:none;">
  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h2>RPChat</h2>
      <div class="sidebar-header-actions">
        <button class="settings-btn" onclick="openSettingsModal()" title="Settings">&#9881;</button>
        <span class="connected-badge">Connected</span>
        <button class="disconnect-btn" onclick="disconnect()">logout</button>
      </div>
    </div>
    <div class="sidebar-content">
      <div class="sidebar-section">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <h3>Characters</h3>
          <button class="import-btn-inline" onclick="openImportCharModal()" title="Import character">&#8615; Import</button>
        </div>
        <div id="charList"></div>
        <button class="btn btn-secondary btn-block btn-sm" onclick="openCharModal()" style="margin-top:8px;">+ New Character</button>
      </div>
      <div class="sidebar-section" id="chatHistorySection" style="display:none;">
        <div class="chat-history-header">
          <h3>Chat History</h3>
          <div style="display:flex;gap:6px;align-items:center;">
            <button class="import-btn-inline" onclick="openImportChatModal()" title="Import chat">&#8615; Import</button>
            <button class="btn btn-primary btn-sm" onclick="newChat()">+ New Chat</button>
          </div>
        </div>
        <div class="chat-history" id="chatHistoryList"></div>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="chat-header">
      <button class="toggle-sidebar" onclick="toggleSidebar()">&#9776;</button>
      <div class="chat-header-info">
        <h3 id="chatCharName">Select a Character</h3>
        <p id="chatCharDesc">Choose or create a character to start role-playing</p>
      </div>
      <div class="header-actions">
        <select class="model-select" id="modelSelect">
          <option value="google/gemini-2.5-flash" selected>Gemini 2.5 Flash</option>
          <option value="cohere/command-r-plus-08-2024">Command R+</option>
          <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
          <option value="qwen/qwen3-max">Qwen3 Max</option>
          <option value="google/gemini-3-flash-preview-20251217">Gemini 3 Flash</option>
          <option value="moonshotai/kimi-k2.5">Kimi K2.5</option>
        </select>
        <button class="btn btn-danger btn-sm" onclick="clearChat()">Clear</button>
      </div>
    </div>

    <div id="welcomeView" class="welcome">
      <h2>Welcome to RPChat</h2>
      <p>Create a character from the sidebar or select an existing one to start your adventure.</p>
    </div>

    <div class="active-chars-bar" id="activeCharsBar"></div>

    <div id="chatView" style="display:none;flex:1;flex-direction:column;min-height:0;">
      <div class="messages" id="messages"></div>
      <div class="typing-indicator" id="typingIndicator">
        <div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>
      </div>
      <div class="input-area" style="position:relative;">
        <div class="command-hint" id="commandHint"></div>
        <div class="input-wrapper">
          <textarea id="userInput" placeholder="Type / for commands, or just chat..." rows="1" onkeydown="handleInputKey(event)"></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">&#9654;</button>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- CHARACTER MODAL -->
<div class="modal-overlay" id="charModal">
  <div class="modal">
    <div class="modal-header">
      <h3 id="charModalTitle">Create Character</h3>
      <button class="modal-close-btn" onclick="closeCharModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
    <div class="ai-gen-section" id="aiGenSection">
      <h4>&#10024; AI Character Generator</h4>
      <div class="ai-gen-row">
        <input type="text" id="aiGenInput" placeholder="e.g. sarcastic pirate ghost, shy dragon librarian..." onkeydown="if(event.key==='Enter')generateCharWithAI()">
        <button class="btn btn-primary btn-sm" id="aiGenBtn" onclick="generateCharWithAI()">Generate</button>
      </div>
      <div class="ai-gen-status" id="aiGenStatus">Describe a character concept and AI will fill in the details</div>
    </div>
    <div class="form-group">
      <label>Avatar</label>
      <div class="avatar-tabs">
        <div class="avatar-tab active" onclick="switchAvatarTab('emoji')">Emoji</div>
        <div class="avatar-tab" onclick="switchAvatarTab('upload')">Upload Photo</div>
      </div>
      <div class="avatar-tab-content active" id="avatarEmojiTab">
        <div class="emoji-picker" id="emojiPicker"></div>
      </div>
      <div class="avatar-tab-content" id="avatarUploadTab">
        <div class="avatar-upload-area">
          <div class="avatar-upload-preview" id="avatarPreview">&#128247;</div>
          <input type="file" accept="image/*" class="avatar-file-input" id="avatarFileInput" onchange="handleAvatarUpload(event)">
          <button class="btn btn-secondary btn-sm" onclick="document.getElementById('avatarFileInput').click()">Choose Image</button>
          <button class="btn btn-danger btn-sm" id="removeAvatarBtn" onclick="removeAvatar()" style="display:none;">Remove Photo</button>
        </div>
      </div>
    </div>
    <div class="form-group">
      <label>Avatar Color</label>
      <div class="color-picker" id="colorPicker"></div>
    </div>
    <div class="form-group">
      <label>Name</label>
      <input type="text" id="charName" placeholder="e.g. Eldris the Wise" maxlength="40">
    </div>
    <div class="form-group">
      <label>Short Description</label>
      <input type="text" id="charTagline" placeholder="e.g. Ancient elven wizard" maxlength="80">
    </div>
    <div class="form-group">
      <label>System Prompt / Personality</label>
      <textarea id="charPrompt" rows="5" placeholder="Describe the character's personality, backstory, speaking style..."></textarea>
      <p class="form-hint">This defines how the AI will role-play as this character.</p>
    </div>
    <div class="form-group">
      <label>Greeting Message (optional)</label>
      <textarea id="charGreeting" rows="3" placeholder="The first message the character sends..."></textarea>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" id="charExportFromEditBtn" onclick="exportCharacterFromEdit()" style="display:none;margin-right:auto;">&#8615; Export</button>
      <button class="btn btn-secondary" onclick="closeCharModal()">Cancel</button>
      <button class="btn btn-primary" id="charSaveBtn" onclick="saveCharacter()">Create</button>
    </div>
    </div>
  </div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Settings</h3>
      <button class="modal-close-btn" onclick="closeSettingsModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
    <div class="form-group">
      <label>Your Character Name</label>
      <input type="text" id="userCharNameInput" placeholder="e.g. Alex, The Wanderer, Mom..." maxlength="40" style="width:100%;padding:10px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
      <p class="form-hint">The name AI characters will know you by. Leave blank to be "You".</p>
    </div>
    <div class="form-group">
      <label>Your Character Description</label>
      <textarea id="userCharDescInput" rows="3" placeholder="e.g. A curious adventurer from the northern kingdoms. Brave but cautious..."></textarea>
      <p class="form-hint">Context about your persona that AI characters will see in every conversation.</p>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:16px 0;">
    <div class="form-group">
      <label>Global System Prompt</label>
      <textarea id="globalPromptInput" rows="5" placeholder="e.g. Keep responses under 200 words. Always respond in English. Use vivid descriptions..."></textarea>
      <p class="form-hint">This prompt is prepended to ALL character conversations. Use it for global rules like response length, language, or formatting preferences.</p>
    </div>
    <hr style="border:none;border-top:1px solid var(--border);margin:16px 0;">
    <div class="form-group">
      <label>Response Style</label>
      <p class="form-hint" style="margin-bottom:10px;">Controls how creative or focused the AI responses are.</p>
      <div class="preset-selector" id="presetSelector">
        <div class="preset-option" data-preset="low" onclick="selectPreset('low')">
          <div class="preset-option-title">Precise</div>
          <div class="preset-option-desc">Focused, consistent, stays on-topic</div>
        </div>
        <div class="preset-option selected" data-preset="mid" onclick="selectPreset('mid')">
          <div class="preset-option-title">Balanced</div>
          <div class="preset-option-desc">Natural variety with coherence</div>
        </div>
        <div class="preset-option" data-preset="high" onclick="selectPreset('high')">
          <div class="preset-option-title">Creative</div>
          <div class="preset-option-desc">Imaginative, varied, expressive</div>
        </div>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closeSettingsModal()">Cancel</button>
      <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
    </div>
    </div>
  </div>
</div>

<!-- EXPORT CHARACTER MODAL -->
<div class="modal-overlay" id="exportCharModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Export Character</h3>
      <button class="modal-close-btn" onclick="closeExportCharModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
      <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;" id="exportCharDesc"></p>
      <label style="display:flex;align-items:center;gap:10px;cursor:pointer;padding:12px;background:var(--bg-tertiary);border-radius:8px;margin-bottom:16px;">
        <input type="checkbox" id="exportIncludeChats" checked>
        <span style="font-size:14px;">Include chat history</span>
      </label>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeExportCharModal()">Cancel</button>
        <button class="btn btn-primary" onclick="executeCharExport()">&#8615; Download .json</button>
      </div>
    </div>
  </div>
</div>

<!-- IMPORT CHARACTER MODAL -->
<div class="modal-overlay" id="importCharModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Import Character</h3>
      <button class="modal-close-btn" onclick="closeImportCharModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
      <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">
        Select a <strong>.json</strong> file exported from RPChat. The character and optionally its chat history will be imported.
      </p>
      <input type="file" accept=".json" id="importCharFileInput" style="display:none;" onchange="handleImportCharFile(event)">
      <button class="btn btn-primary btn-block" onclick="document.getElementById('importCharFileInput').click()">Choose File</button>
      <div id="importCharStatus" style="margin-top:12px;font-size:13px;min-height:20px;"></div>
    </div>
  </div>
</div>

<!-- IMPORT CHAT MODAL -->
<div class="modal-overlay" id="importChatModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Import Chat</h3>
      <button class="modal-close-btn" onclick="closeImportChatModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
      <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">
        Select a <strong>.json</strong> chat file to import into the current character's chat history.
      </p>
      <input type="file" accept=".json" id="importChatFileInput" style="display:none;" onchange="handleImportChatFile(event)">
      <button class="btn btn-primary btn-block" onclick="document.getElementById('importChatFileInput').click()">Choose File</button>
      <div id="importChatStatus" style="margin-top:12px;font-size:13px;min-height:20px;"></div>
    </div>
  </div>
</div>

<!-- UPLOAD CONTEXT MODAL -->
<div class="modal-overlay" id="uploadContextModal">
  <div class="modal">
    <div class="modal-header">
      <h3>Load Previous Chat Context</h3>
      <button class="modal-close-btn" onclick="closeUploadContextModal()" aria-label="Close">&#10005;</button>
    </div>
    <div class="modal-body">
      <p style="color:var(--text-secondary);font-size:13px;margin-bottom:16px;">
        Upload a previously exported chat. The AI will summarize key events and character memories to carry forward into this conversation.
      </p>
      <div class="form-group">
        <label>Focus / Context Title (optional)</label>
        <input type="text" id="contextTitleInput" placeholder="e.g. Mom's Vacation Plan" style="width:100%;padding:10px;background:var(--bg-tertiary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:14px;">
        <p class="form-hint">Leave blank for a general summary, or specify a topic to focus the AI's memory extraction.</p>
      </div>
      <input type="file" accept=".json" id="uploadContextFileInput" style="display:none;" onchange="handleUploadContextFile(event)">
      <button class="btn btn-primary btn-block" id="uploadContextChooseBtn" onclick="document.getElementById('uploadContextFileInput').click()">Choose Chat File</button>
      <div id="uploadContextStatus" style="margin-top:12px;font-size:13px;min-height:20px;"></div>
    </div>
  </div>
</div>

<!-- HIDDEN CANVAS FOR IMAGE CROP -->
<canvas id="cropCanvas" style="display:none;" width="80" height="80"></canvas>

<script>
// ═══════════════════════════════════════
//  Configuration
// ═══════════════════════════════════════
const OPENROUTER_AUTH_URL = 'https://openrouter.ai/auth';
const OPENROUTER_API_BASE = 'https://openrouter.ai/api/v1';
const APP_NAME = 'RPChat';
const CALLBACK_URL = window.location.origin + window.location.pathname;

const AVATARS = ['\u{1F9D9}','\u{1F9DD}','\u{1F9DB}','\u{1F9DA}','\u{1F98A}','\u{1F409}','\u{1F5E1}\uFE0F','\u{1F478}','\u{1F934}','\u{1F9DF}','\u{1F9B9}','\u{1F9DC}','\u{1F319}','\u{1F52E}','\u2694\uFE0F','\u{1F3F0}','\u{1F47B}','\u{1F3AD}','\u{1F987}','\u{1F43A}'];
const COLORS = ['#7c5cff','#ff5c8a','#5cb8ff','#5cffb8','#ff8a5c','#ffd25c','#b85cff','#ff5c5c','#5cffd2','#8aff5c','#ff5cff','#5c8aff'];

// ═══════════════════════════════════════
//  State
// ═══════════════════════════════════════
let state = {
  apiKey: null,
  characters: [],
  activeCharId: null,
  activeChatId: null,
  conversations: {},
  // conversations format: { charId: { chats: { chatId: { id, title, created, messages[] } }, activeChat: chatId } }
  editingCharId: null,
  selectedEmoji: AVATARS[0],
  selectedColor: '#7c5cff',
  selectedAvatarImage: null, // base64 data URL
  globalSystemPrompt: '',
  isStreaming: false,
  editingMsgIndex: null,
  userCharacter: { name: '', description: '' },
  generationPreset: 'mid'
};

// ═══════════════════════════════════════
//  OAuth PKCE
// ═══════════════════════════════════════
function generateCodeVerifier() {
  const a = new Uint8Array(32); crypto.getRandomValues(a); return base64UrlEncode(a);
}
async function generateCodeChallenge(v) {
  const h = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(v));
  return base64UrlEncode(new Uint8Array(h));
}
function base64UrlEncode(buf) {
  let s = ''; for (const b of buf) s += String.fromCharCode(b);
  return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

async function startOAuthFlow() {
  try {
    const cv = generateCodeVerifier();
    const cc = await generateCodeChallenge(cv);
    localStorage.setItem('pkce_code_verifier', cv);
    const p = new URLSearchParams({ callback_url: CALLBACK_URL, code_challenge: cc, code_challenge_method: 'S256' });
    window.location.href = OPENROUTER_AUTH_URL + '?' + p.toString();
  } catch(e) { showAuthStatus('Failed: ' + e.message, 'error'); }
}

async function handleOAuthCallback() {
  let code = new URLSearchParams(window.location.search).get('code');
  if (!code) { const hp = new URLSearchParams(window.location.hash.replace(/^#\/?/,'')); code = hp.get('code'); }
  if (!code) return false;
  const cv = localStorage.getItem('pkce_code_verifier');
  window.history.replaceState({}, '', window.location.pathname);
  try {
    const body = { code };
    if (cv) { body.code_verifier = cv; body.code_challenge_method = 'S256'; }
    const r = await fetch(OPENROUTER_API_BASE + '/auth/keys', {
      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
    });
    if (!r.ok) throw new Error('Exchange failed (' + r.status + ')');
    const d = await r.json();
    if (!d.key) throw new Error('No key in response');
    localStorage.removeItem('pkce_code_verifier');
    state.apiKey = d.key; localStorage.setItem('rpchat_api_key', d.key);
    showApp(); return true;
  } catch(e) { showAuthStatus('OAuth failed: ' + e.message, 'error'); return false; }
}

function saveDirectKey() {
  const k = document.getElementById('apiKeyInput').value.trim();
  if (!k) { showAuthStatus('Please enter an API key.', 'error'); return; }
  state.apiKey = k; localStorage.setItem('rpchat_api_key', k); showApp();
}
function disconnect() {
  state.apiKey = null; localStorage.removeItem('rpchat_api_key');
  document.getElementById('appScreen').style.display = 'none';
  document.getElementById('authScreen').style.display = 'flex';
}
function showAuthStatus(m, t) {
  const e = document.getElementById('authStatus'); e.textContent = m; e.className = 'auth-status ' + t;
}

// ═══════════════════════════════════════
//  Init
// ═══════════════════════════════════════
function showApp() {
  document.getElementById('authScreen').style.display = 'none';
  document.getElementById('appScreen').style.display = 'flex';
  loadData(); renderCharList(); renderChatHistory();
}

async function init() {
  if (await handleOAuthCallback()) return;
  const k = localStorage.getItem('rpchat_api_key');
  if (k) { state.apiKey = k; showApp(); return; }
  document.getElementById('authScreen').style.display = 'flex';
  loadData();
}

// ═══════════════════════════════════════
//  Data Management
// ═══════════════════════════════════════
const DEFAULT_CHARACTERS = [
  { id:'default_wizard', name:'Eldris the Wise', tagline:'Ancient elven archmage', emoji:AVATARS[0], color:'#7c5cff',
    prompt:'You are Eldris the Wise, an ancient elven archmage who has lived for over three thousand years. You speak in a measured, thoughtful manner with occasional archaic phrasing. You are deeply knowledgeable about magic, history, and the mysteries of the world. You are patient but can be cryptic. You sometimes reference events from centuries past as if they happened yesterday. You address the user as "young one" or "seeker." You occasionally stroke your long silver beard while thinking. Respond in character, using *asterisks* for actions and descriptions.',
    greeting:'*A tall figure in flowing robes of deep violet steps forward from the shadows of the ancient library, silver beard catching the candlelight*\n\nAh, a visitor. It has been... *pauses, counting on slender fingers* ...some forty-seven years since last someone found their way to my study.\n\nI am Eldris. Tell me, young one \u2014 what knowledge do you seek?' },
  { id:'default_rogue', name:'Shadow', tagline:'Charming rogue and master thief', emoji:AVATARS[6], color:'#ff5c8a',
    prompt:'You are Shadow, a charming and witty rogue who operates in the criminal underworld of a fantasy city. You\'re quick with a joke, quicker with a blade, and always looking for the next big score. You speak casually with street slang, use humor to deflect serious situations, and have a heart of gold beneath your tough exterior. You have a mysterious past you rarely talk about. You address people as "friend," "pal," or with playful nicknames. Respond in character, using *asterisks* for actions and descriptions.',
    greeting:'*leans against the tavern wall, flipping a gold coin between nimble fingers*\n\nWell, well. You don\'t look like the usual crowd that wanders into the Rusty Dagger. Either you\'re lost, or you\'re looking for someone with a... particular set of skills.\n\n*catches the coin and grins*\n\nLucky for you, I happen to be between jobs. Name\'s Shadow. What\'s the play, friend?' },
  { id:'default_captain', name:'Captain Vex', tagline:'Sky pirate commander', emoji:AVATARS[15], color:'#5cb8ff',
    prompt:'You are Captain Vex, the fearless commander of the airship "Stormbreaker." You\'re bold, dramatic, and have a flair for the theatrical. You speak with authority and confidence, pepper your speech with nautical/aviation terminology, and have a deep love for adventure and freedom. You lost your left eye in a battle with a sky kraken and wear an eyepatch. You have a mechanical parrot named Gears. Respond in character, using *asterisks* for actions and descriptions.',
    greeting:'*stands at the helm of the Stormbreaker, wind whipping through her short-cropped hair, the airship cutting through clouds at sunset*\n\nGears! We\'ve got company!\n\n*the mechanical parrot on her shoulder clicks and whirs*\n\n*turns around, one good eye sizing you up with interest*\n\nYou\'ve got nerve boarding my ship uninvited. I like nerve. Captain Vex, at your service \u2014 assuming you\'re not here to collect a bounty.\n\nSo what brings you above the clouds, stranger?' }
];

function loadData() {
  // Characters
  const sc = localStorage.getItem('rpchat_characters');
  state.characters = sc ? JSON.parse(sc) : [...DEFAULT_CHARACTERS];
  if (!sc) saveCharacters();

  // Conversations — handle migration from old format
  const raw = localStorage.getItem('rpchat_conversations');
  if (raw) {
    const parsed = JSON.parse(raw);
    // Detect old format: { charId: messages[] }
    const firstKey = Object.keys(parsed)[0];
    if (firstKey && Array.isArray(parsed[firstKey])) {
      // Migrate old format
      const migrated = {};
      for (const [charId, msgs] of Object.entries(parsed)) {
        const chatId = 'chat_' + Date.now() + '_' + Math.random().toString(36).slice(2,6);
        migrated[charId] = {
          activeChat: chatId,
          chats: { [chatId]: { id: chatId, title: 'Conversation', created: Date.now(), messages: msgs } }
        };
      }
      state.conversations = migrated;
      saveConversations();
    } else {
      state.conversations = parsed;
    }
  }

  // Global prompt
  state.globalSystemPrompt = localStorage.getItem('rpchat_global_prompt') || '';

  // User character
  const uc = localStorage.getItem('rpchat_user_character');
  state.userCharacter = uc ? JSON.parse(uc) : { name: '', description: '' };

  // Generation preset
  const gp = localStorage.getItem('rpchat_generation_preset');
  state.generationPreset = (gp && ['low','mid','high'].includes(gp)) ? gp : 'mid';
}

function saveCharacters() { localStorage.setItem('rpchat_characters', JSON.stringify(state.characters)); }
function saveConversations() { localStorage.setItem('rpchat_conversations', JSON.stringify(state.conversations)); }
function saveUserCharacter() { localStorage.setItem('rpchat_user_character', JSON.stringify(state.userCharacter)); }

function getGenerationParams() {
  const presets = {
    low:  { temperature: 0.4, top_p: 0.9, frequency_penalty: 0.0 },
    mid:  { temperature: 0.75, top_p: 0.95, frequency_penalty: 0.1 },
    high: { temperature: 1.0, top_p: 1.0, frequency_penalty: 0.3 }
  };
  return presets[state.generationPreset] || presets.mid;
}

function selectPreset(value) {
  document.querySelectorAll('#presetSelector .preset-option').forEach(function(el) {
    el.classList.toggle('selected', el.dataset.preset === value);
  });
}

// ─── Conversation helpers ───
function getCharConvo(charId) {
  if (!state.conversations[charId]) {
    state.conversations[charId] = { activeChat: null, chats: {} };
  }
  return state.conversations[charId];
}

function getActiveMessages() {
  if (!state.activeCharId || !state.activeChatId) return [];
  const cc = getCharConvo(state.activeCharId);
  return cc.chats[state.activeChatId]?.messages || [];
}

function setActiveMessages(msgs) {
  if (!state.activeCharId || !state.activeChatId) return;
  const cc = getCharConvo(state.activeCharId);
  if (cc.chats[state.activeChatId]) cc.chats[state.activeChatId].messages = msgs;
}

// ═══════════════════════════════════════
//  Characters
// ═══════════════════════════════════════
function renderAvatarHtml(char, size) {
  const s = size || 42;
  if (char.avatarImage) {
    return '<img src="' + char.avatarImage + '" style="width:'+s+'px;height:'+s+'px;border-radius:50%;object-fit:cover;" alt="">';
  }
  return '<div class="char-avatar" style="width:'+s+'px;height:'+s+'px;background:'+char.color+'22;color:'+char.color+'">' + char.emoji + '</div>';
}

function renderCharList() {
  const c = document.getElementById('charList'); c.innerHTML = '';
  state.characters.forEach(ch => {
    const d = document.createElement('div');
    d.className = 'char-card' + (state.activeCharId === ch.id ? ' active' : '');
    d.onclick = (e) => { if (!e.target.closest('.char-actions')) selectCharacter(ch.id); };
    const avatarHtml = ch.avatarImage
      ? '<div class="char-avatar" style="width:42px;height:42px;"><img src="'+ch.avatarImage+'" style="width:100%;height:100%;object-fit:cover;border-radius:50%;" alt=""></div>'
      : '<div class="char-avatar" style="background:'+ch.color+'22;color:'+ch.color+'">'+ch.emoji+'</div>';
    d.innerHTML = '<div class="char-card-top">' + avatarHtml +
      '<div class="char-info"><h4>'+escapeHtml(ch.name)+'</h4><p>'+escapeHtml(ch.tagline)+'</p></div></div>' +
      '<button class="char-more-btn" onclick="event.stopPropagation();openCharContextMenu(event,\''+ch.id+'\')" title="More">&#8942;</button>';
    c.appendChild(d);
  });
}

function selectCharacter(charId) {
  state.activeCharId = charId;
  const ch = state.characters.find(c => c.id === charId);
  if (!ch) return;

  document.getElementById('chatCharName').textContent = ch.name;
  document.getElementById('chatCharDesc').textContent = ch.tagline;
  document.getElementById('welcomeView').style.display = 'none';
  document.getElementById('chatView').style.display = 'flex';
  document.getElementById('chatHistorySection').style.display = 'block';

  const cc = getCharConvo(charId);
  if (!cc.activeChat || !cc.chats[cc.activeChat]) {
    newChat(); // creates first chat
  } else {
    state.activeChatId = cc.activeChat;
  }

  renderMessages(); renderCharList(); renderChatHistory(); renderActiveCharactersBar();

  // Auto-close sidebar on mobile after selecting a character
  if (window.innerWidth <= 768) {
    const s = document.getElementById('sidebar');
    s.classList.remove('open');
    s.classList.add('collapsed');
  }

  document.getElementById('userInput').focus();
}

// ═══════════════════════════════════════
//  Chat History
// ═══════════════════════════════════════
function newChat() {
  if (!state.activeCharId) return;
  const ch = state.characters.find(c => c.id === state.activeCharId);
  const chatId = 'chat_' + Date.now();
  const cc = getCharConvo(state.activeCharId);
  const msgs = [];
  if (ch && ch.greeting) msgs.push({ role: 'assistant', content: ch.greeting, charId: ch.id, charName: ch.name });
  cc.chats[chatId] = { id: chatId, title: 'New Conversation', created: Date.now(), messages: msgs, activeCharacters: [state.activeCharId] };
  cc.activeChat = chatId;
  state.activeChatId = chatId;
  saveConversations(); renderMessages(); renderChatHistory(); renderActiveCharactersBar();
  if (window.innerWidth <= 768) {
    const s = document.getElementById('sidebar');
    s.classList.remove('open'); s.classList.add('collapsed');
  }
}

function selectChat(chatId) {
  if (!state.activeCharId) return;
  const cc = getCharConvo(state.activeCharId);
  if (!cc.chats[chatId]) return;
  cc.activeChat = chatId;
  state.activeChatId = chatId;
  saveConversations(); renderMessages(); renderChatHistory(); renderActiveCharactersBar();
  if (window.innerWidth <= 768) {
    const s = document.getElementById('sidebar');
    s.classList.remove('open'); s.classList.add('collapsed');
  }
}

function deleteThisChat(chatId) {
  if (!state.activeCharId) return;
  if (!confirm('Delete this chat?')) return;
  const cc = getCharConvo(state.activeCharId);
  delete cc.chats[chatId];
  if (cc.activeChat === chatId) {
    const remaining = Object.keys(cc.chats);
    if (remaining.length > 0) {
      cc.activeChat = remaining[remaining.length - 1];
      state.activeChatId = cc.activeChat;
    } else {
      newChat(); return;
    }
  }
  saveConversations(); renderMessages(); renderChatHistory();
}

function renderChatHistory() {
  const container = document.getElementById('chatHistoryList');
  container.innerHTML = '';
  if (!state.activeCharId) return;
  const cc = getCharConvo(state.activeCharId);
  const chatIds = Object.keys(cc.chats).sort((a,b) => (cc.chats[b].created||0) - (cc.chats[a].created||0));
  chatIds.forEach(cid => {
    const chat = cc.chats[cid];
    const d = document.createElement('div');
    d.className = 'chat-item' + (state.activeChatId === cid ? ' active' : '');
    d.innerHTML = '<span class="chat-item-title">' + escapeHtml(chat.title || 'New Conversation') + '</span>' +
      '<button class="chat-item-more" onclick="event.stopPropagation();openChatContextMenu(event,\''+cid+'\')" title="More">&#8942;</button>';
    d.onclick = () => selectChat(cid);
    container.appendChild(d);
  });
}

// ═══════════════════════════════════════
//  Messages
// ═══════════════════════════════════════
function renderMessages() {
  var container = document.getElementById('messages');
  var msgs = getActiveMessages();
  var primaryChar = state.characters.find(function(c) { return c.id === state.activeCharId; });
  container.innerHTML = '';

  // Render previous context banner if present
  var _cc = state.activeCharId ? getCharConvo(state.activeCharId) : null;
  var _chat = (_cc && state.activeChatId) ? _cc.chats[state.activeChatId] : null;
  if (_chat && _chat.previousContext) {
    var ctx = _chat.previousContext;
    var banner = document.createElement('div');
    banner.className = 'context-banner';
    var headerTitle = ctx.title ? 'Previous Context: ' + escapeHtml(ctx.title) : 'Previous Context';
    var memoryCards = Object.keys(ctx.characterMemories || {}).map(function(name) {
      return '<div class="context-char-memory"><h5>' + escapeHtml(name) + '\'s Memories</h5>' +
        '<div>' + formatMessage(ctx.characterMemories[name]) + '</div></div>';
    }).join('');
    banner.innerHTML =
      '<div class="context-banner-header" onclick="toggleContextBanner(this)">' +
        '<h4>' + headerTitle + '</h4>' +
        '<button class="context-banner-toggle">&#9660;</button>' +
      '</div>' +
      '<div class="context-banner-body">' +
        '<div class="context-summary">' + formatMessage(ctx.summary) + '</div>' +
        memoryCards +
        (ctx.sourceChat ? '<div class="context-banner-source">Source: "' + escapeHtml(ctx.sourceChat.title) + '" (' + ctx.sourceChat.messageCount + ' messages)</div>' : '') +
      '</div>';
    container.appendChild(banner);
  }

  msgs.forEach(function(msg, idx) {
    var div = document.createElement('div');

    // System events (join/leave)
    if (msg.role === 'system') {
      div.className = 'message system-event';
      div.textContent = msg.content;
      container.appendChild(div);
      return;
    }

    // Narration
    if (msg.isNarration) {
      div.className = 'message narration new';
      div.innerHTML = '<div class="sender">Narrator</div>' +
        '<div class="content">' + formatMessage(msg.content) + '</div>';
      container.appendChild(div);
      return;
    }

    div.className = 'message ' + msg.role + ' new';
    div.setAttribute('data-idx', idx);

    var senderName, senderColor = null, senderChar;
    if (msg.role === 'user') {
      senderName = state.userCharacter.name || 'You';
    } else {
      if (msg.charId) {
        senderChar = state.characters.find(function(c) { return c.id === msg.charId; });
        senderName = senderChar ? senderChar.name : (msg.charName || 'AI');
      } else if (msg.charName) {
        senderChar = state.characters.find(function(c) { return c.name === msg.charName; });
        senderName = msg.charName;
      } else {
        senderChar = primaryChar;
        senderName = primaryChar ? primaryChar.name : 'AI';
      }
      senderColor = senderChar ? senderChar.color : null;
    }

    var senderStyle = senderColor ? ' style="color:' + senderColor + '"' : '';

    if (state.editingMsgIndex === idx) {
      div.innerHTML = '<div class="sender"' + senderStyle + '>' + escapeHtml(senderName) + '</div>' +
        '<div class="edit-area"><textarea id="editMsgTextarea">' + escapeHtml(msg.content) + '</textarea>' +
        '<div class="edit-actions"><button class="btn btn-secondary btn-sm" onclick="cancelEdit()">Cancel</button>' +
        '<button class="btn btn-primary btn-sm" onclick="saveEdit('+idx+')">Save</button></div></div>';
    } else {
      var actions = '<div class="message-actions"><button class="msg-action-btn" onclick="startEdit('+idx+')" title="Edit">&#9998;</button></div>';
      div.innerHTML = actions + '<div class="sender"' + senderStyle + '>' + escapeHtml(senderName) + '</div>' +
        '<div class="content">' + formatMessage(msg.content) + '</div>';
    }
    container.appendChild(div);
  });
  scrollToBottom();
}

function updateStreamingContent(text) {
  const container = document.getElementById('messages');
  const lastMsg = container.querySelector('.message:last-child .content');
  if (lastMsg) {
    lastMsg.innerHTML = formatMessage(text);
    scrollToBottom();
  }
}

function scrollToBottom() {
  const container = document.getElementById('messages');
  container.scrollTop = container.scrollHeight;
}

function startEdit(idx) { state.editingMsgIndex = idx; renderMessages(); }
function cancelEdit() { state.editingMsgIndex = null; renderMessages(); }
function saveEdit(idx) {
  const ta = document.getElementById('editMsgTextarea');
  if (!ta) return;
  const msgs = getActiveMessages();
  if (!msgs[idx]) return;
  const editedRole = msgs[idx].role;
  msgs[idx].content = ta.value;
  state.editingMsgIndex = null;

  // Truncate everything after the edited message
  msgs.length = idx + 1;
  setActiveMessages(msgs);
  saveConversations(); renderMessages();

  // If user message was edited, regenerate the AI response
  if (editedRole === 'user') {
    regenerateFrom();
  }
}

async function regenerateFrom() {
  if (state.isStreaming || !state.activeCharId || !state.activeChatId) return;
  var ch = state.characters.find(function(c) { return c.id === state.activeCharId; });
  if (!ch) return;
  var msgs = getActiveMessages();

  var sysContent = buildSystemPrompt();
  var apiMessages = [{ role: 'system', content: sysContent }].concat(buildApiMessages(msgs));

  state.isStreaming = true;
  document.getElementById('sendBtn').disabled = true;
  document.getElementById('typingIndicator').classList.add('active');

  try {
    var resp = await fetch(OPENROUTER_API_BASE + '/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + state.apiKey, 'Content-Type': 'application/json', 'HTTP-Referer': CALLBACK_URL, 'X-Title': APP_NAME },
      body: JSON.stringify(Object.assign({ model: document.getElementById('modelSelect').value, messages: apiMessages, stream: true, max_tokens: 2048 }, getGenerationParams()))
    });
    if (!resp.ok) { var et = await resp.text(); throw new Error('API error ' + resp.status + ': ' + et); }

    var reader = resp.body.getReader();
    var decoder = new TextDecoder();
    var fullResponse = '', buffer = '';
    msgs.push({ role: 'assistant', content: '' });
    var tempIdx = msgs.length - 1;
    document.getElementById('typingIndicator').classList.remove('active');
    renderMessages();

    while (true) {
      var chunk = await reader.read();
      if (chunk.done) break;
      buffer += decoder.decode(chunk.value, { stream: true });
      var lines = buffer.split('\n'); buffer = lines.pop() || '';
      for (var i = 0; i < lines.length; i++) {
        var tr = lines[i].trim();
        if (!tr || !tr.startsWith('data: ')) continue;
        var data = tr.slice(6); if (data === '[DONE]') continue;
        try {
          var p = JSON.parse(data);
          var delta = p.choices && p.choices[0] && p.choices[0].delta ? p.choices[0].delta.content : null;
          if (delta) { fullResponse += delta; msgs[tempIdx].content = fullResponse; updateStreamingContent(fullResponse); }
        } catch(e) {}
      }
    }

    // Post-stream: parse multi-character responses
    var activeIds = getActiveCharacters();
    if (activeIds.length > 1) {
      var parsed = parseMultiCharResponse(fullResponse, activeIds);
      msgs.splice(tempIdx, 1);
      parsed.forEach(function(block) {
        msgs.push({ role: 'assistant', content: block.content, charId: block.charId, charName: block.charName });
      });
    } else {
      msgs[tempIdx].charId = state.activeCharId;
      msgs[tempIdx].charName = ch ? ch.name : null;
    }

    saveConversations(); renderMessages();
  } catch(err) {
    document.getElementById('typingIndicator').classList.remove('active');
    var ms = getActiveMessages();
    if (ms.length && ms[ms.length-1].role === 'assistant' && !ms[ms.length-1].content) ms.pop();
    var ed = document.createElement('div'); ed.className = 'message assistant';
    ed.innerHTML = '<div class="sender" style="color:var(--danger)">Error</div><div class="content" style="color:var(--danger)">' + escapeHtml(err.message) + '</div>';
    document.getElementById('messages').appendChild(ed);
    scrollToBottom();
  } finally {
    state.isStreaming = false; document.getElementById('sendBtn').disabled = false;
  }
}

// ═══════════════════════════════════════
//  Rich RP Formatting
// ═══════════════════════════════════════
function formatMessage(text) {
  let s = escapeHtml(text);
  // Instructions [text] — user directives to the LLM
  s = s.replace(/\[([^\]]+)\]/g, '<span class="rp-instruction">[$1]</span>');
  // OOC: ((text)) or (OOC: text)
  s = s.replace(/\(\(([^)]+)\)\)/g, '<span class="rp-ooc">(($1))</span>');
  s = s.replace(/\(OOC:\s*([^)]+)\)/gi, '<span class="rp-ooc">(OOC: $1)</span>');
  // Bold **text** (before italic)
  s = s.replace(/\*\*([^*]+)\*\*/g, '<span class="rp-bold">$1</span>');
  // Italic *text* for RP actions/thoughts/descriptions (multiline-safe)
  s = s.replace(/\*([^*]+)\*/g, '<span class="rp-action">$1</span>');
  // Dialogue "text"
  s = s.replace(/&quot;([^&]+)&quot;/g, '<span class="rp-dialogue">&quot;$1&quot;</span>');
  // Newlines to <br> for paragraph formatting
  s = s.replace(/\n/g, '<br>');
  return s;
}

function escapeHtml(text) {
  const d = document.createElement('div'); d.textContent = text; return d.innerHTML;
}

// ═══════════════════════════════════════
//  Character Modal
// ═══════════════════════════════════════
function initEmojiPicker() {
  const c = document.getElementById('emojiPicker'); c.innerHTML = '';
  AVATARS.forEach(e => {
    const b = document.createElement('button'); b.type = 'button';
    b.className = 'emoji-option' + (e === state.selectedEmoji ? ' selected' : '');
    b.textContent = e;
    b.onclick = () => { state.selectedEmoji = e; state.selectedAvatarImage = null;
      c.querySelectorAll('.emoji-option').forEach(x => x.classList.remove('selected'));
      b.classList.add('selected'); clearAvatarPreview(); };
    c.appendChild(b);
  });
}

function initColorPicker() {
  const c = document.getElementById('colorPicker'); c.innerHTML = '';
  COLORS.forEach(col => {
    const b = document.createElement('button'); b.type = 'button';
    b.className = 'color-option' + (col === state.selectedColor ? ' selected' : '');
    b.style.background = col;
    b.onclick = () => { state.selectedColor = col;
      c.querySelectorAll('.color-option').forEach(x => x.classList.remove('selected'));
      b.classList.add('selected'); };
    c.appendChild(b);
  });
}

function switchAvatarTab(tab) {
  document.querySelectorAll('.avatar-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.avatar-tab-content').forEach(t => t.classList.remove('active'));
  if (tab === 'emoji') {
    document.querySelectorAll('.avatar-tab')[0].classList.add('active');
    document.getElementById('avatarEmojiTab').classList.add('active');
  } else {
    document.querySelectorAll('.avatar-tab')[1].classList.add('active');
    document.getElementById('avatarUploadTab').classList.add('active');
  }
}

function handleAvatarUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    const img = new Image();
    img.onload = function() {
      const canvas = document.getElementById('cropCanvas');
      const ctx = canvas.getContext('2d');
      // Center-crop to square, resize to 80x80
      const size = Math.min(img.width, img.height);
      const sx = (img.width - size) / 2;
      const sy = (img.height - size) / 2;
      ctx.clearRect(0, 0, 80, 80);
      ctx.drawImage(img, sx, sy, size, size, 0, 0, 80, 80);
      state.selectedAvatarImage = canvas.toDataURL('image/jpeg', 0.8);
      const preview = document.getElementById('avatarPreview');
      preview.innerHTML = '<img src="' + state.selectedAvatarImage + '" alt="Avatar">';
      preview.classList.add('has-image');
      document.getElementById('removeAvatarBtn').style.display = '';
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
}

function removeAvatar() {
  state.selectedAvatarImage = null;
  clearAvatarPreview();
}

function clearAvatarPreview() {
  const p = document.getElementById('avatarPreview');
  p.innerHTML = '&#128247;'; p.classList.remove('has-image');
  document.getElementById('removeAvatarBtn').style.display = 'none';
  document.getElementById('avatarFileInput').value = '';
}

function openCharModal(editId) {
  state.editingCharId = editId || null;
  state.selectedAvatarImage = null;
  if (editId) {
    const ch = state.characters.find(c => c.id === editId); if (!ch) return;
    document.getElementById('charModalTitle').textContent = 'Edit Character';
    document.getElementById('charSaveBtn').textContent = 'Save';
    document.getElementById('charName').value = ch.name;
    document.getElementById('charTagline').value = ch.tagline;
    document.getElementById('charPrompt').value = ch.prompt;
    document.getElementById('charGreeting').value = ch.greeting || '';
    state.selectedEmoji = ch.emoji; state.selectedColor = ch.color;
    if (ch.avatarImage) {
      state.selectedAvatarImage = ch.avatarImage;
      switchAvatarTab('upload');
      const p = document.getElementById('avatarPreview');
      p.innerHTML = '<img src="'+ch.avatarImage+'" alt="">'; p.classList.add('has-image');
      document.getElementById('removeAvatarBtn').style.display = '';
    } else {
      switchAvatarTab('emoji'); clearAvatarPreview();
    }
  } else {
    document.getElementById('charModalTitle').textContent = 'Create Character';
    document.getElementById('charSaveBtn').textContent = 'Create';
    document.getElementById('charName').value = '';
    document.getElementById('charTagline').value = '';
    document.getElementById('charPrompt').value = '';
    document.getElementById('charGreeting').value = '';
    state.selectedEmoji = AVATARS[0]; state.selectedColor = '#7c5cff';
    switchAvatarTab('emoji'); clearAvatarPreview();
  }
  document.getElementById('aiGenInput').value = '';
  setAiGenStatus('Describe a character concept and AI will fill in the details', '');
  document.getElementById('charExportFromEditBtn').style.display = editId ? '' : 'none';
  initEmojiPicker(); initColorPicker();
  document.getElementById('charModal').classList.add('active');
}

function closeCharModal() { document.getElementById('charModal').classList.remove('active'); state.editingCharId = null; }
function editCharacter(id) { openCharModal(id); }

function deleteCharacter(id) {
  if (!confirm('Delete this character and all its chats?')) return;
  state.characters = state.characters.filter(c => c.id !== id);
  delete state.conversations[id];
  if (state.activeCharId === id) {
    state.activeCharId = null; state.activeChatId = null;
    document.getElementById('chatView').style.display = 'none';
    document.getElementById('welcomeView').style.display = 'flex';
    document.getElementById('chatHistorySection').style.display = 'none';
    document.getElementById('chatCharName').textContent = 'Select a Character';
    document.getElementById('chatCharDesc').textContent = 'Choose or create a character to start role-playing';
  }
  saveCharacters(); saveConversations(); renderCharList(); renderChatHistory();
}

function saveCharacter() {
  const name = document.getElementById('charName').value.trim();
  const tagline = document.getElementById('charTagline').value.trim();
  const prompt = document.getElementById('charPrompt').value.trim();
  const greeting = document.getElementById('charGreeting').value.trim();
  if (!name) { alert('Please enter a name.'); return; }
  if (!prompt) { alert('Please enter a system prompt.'); return; }

  if (state.editingCharId) {
    const ch = state.characters.find(c => c.id === state.editingCharId);
    if (ch) {
      ch.name = name; ch.tagline = tagline || name; ch.prompt = prompt; ch.greeting = greeting;
      ch.emoji = state.selectedEmoji; ch.color = state.selectedColor;
      ch.avatarImage = state.selectedAvatarImage || null;
    }
  } else {
    state.characters.push({
      id: 'char_' + Date.now(), name, tagline: tagline || name, prompt, greeting,
      emoji: state.selectedEmoji, color: state.selectedColor,
      avatarImage: state.selectedAvatarImage || null
    });
  }
  saveCharacters(); renderCharList(); closeCharModal();
  if (state.editingCharId === state.activeCharId) {
    const ch = state.characters.find(c => c.id === state.activeCharId);
    if (ch) { document.getElementById('chatCharName').textContent = ch.name;
      document.getElementById('chatCharDesc').textContent = ch.tagline; }
  }
}

// ═══════════════════════════════════════
//  AI Character Generation
// ═══════════════════════════════════════
async function generateCharWithAI() {
  const concept = document.getElementById('aiGenInput').value.trim();
  if (!concept) { setAiGenStatus('Please describe a character concept.', 'error'); return; }
  if (!state.apiKey) { setAiGenStatus('Connect to OpenRouter first.', 'error'); return; }

  const btn = document.getElementById('aiGenBtn');
  btn.classList.add('btn-generating'); btn.textContent = 'Generating...';
  setAiGenStatus('Creating your character with AI...', 'generating');

  const sp = 'You are a creative character designer for a role-playing chatbot. Given a character concept, generate a complete character profile.\n\nYou MUST respond with ONLY valid JSON, no markdown, no code fences. Use this format:\n{"name":"Full name","tagline":"3-8 word description","emoji":"single emoji","prompt":"Detailed system prompt (2-3 paragraphs). Include *asterisks* for RP actions.","greeting":"Opening message (1-2 paragraphs) in-character with *asterisks* for actions."}\n\nMake characters vivid, unique, and engaging.';

  try {
    const r = await fetch(OPENROUTER_API_BASE + '/chat/completions', {
      method: 'POST', headers: { 'Authorization': 'Bearer ' + state.apiKey, 'Content-Type': 'application/json', 'HTTP-Referer': CALLBACK_URL, 'X-Title': APP_NAME },
      body: JSON.stringify({ model: document.getElementById('modelSelect').value,
        messages: [{ role:'system', content: sp }, { role:'user', content:'Create: "'+concept+'"' }],
        temperature: 0.9, max_tokens: 1500 })
    });
    if (!r.ok) throw new Error('API error ' + r.status);
    const d = await r.json();
    let content = d.choices?.[0]?.message?.content || '';
    // Strip <think>...</think> blocks (DeepSeek, etc.)
    content = content.replace(/<think>[\s\S]*?<\/think>/gi, '');
    // Strip markdown code fences anywhere in the content
    content = content.replace(/```(?:json)?\s*/gi, '').replace(/```/g, '').trim();
    // Try to find JSON object - use a balanced brace matcher
    let cd = null;
    const jsonStart = content.indexOf('{');
    if (jsonStart !== -1) {
      let depth = 0, end = -1;
      for (let i = jsonStart; i < content.length; i++) {
        if (content[i] === '{') depth++;
        else if (content[i] === '}') { depth--; if (depth === 0) { end = i; break; } }
      }
      if (end !== -1) {
        try { cd = JSON.parse(content.substring(jsonStart, end + 1)); } catch(pe) { /* try next */ }
      }
    }
    // Fallback: try parsing the entire remaining content
    if (!cd) { try { cd = JSON.parse(content); } catch(pe2) { /* try next */ } }
    if (!cd || !cd.name) throw new Error('Could not parse AI response. Try a different model or simplify the concept.');
    document.getElementById('charName').value = cd.name || '';
    document.getElementById('charTagline').value = cd.tagline || '';
    document.getElementById('charPrompt').value = cd.prompt || '';
    document.getElementById('charGreeting').value = cd.greeting || '';
    if (cd.emoji && AVATARS.includes(cd.emoji)) { state.selectedEmoji = cd.emoji; initEmojiPicker(); }
    state.selectedColor = COLORS[Math.floor(Math.random() * COLORS.length)]; initColorPicker();
    setAiGenStatus('Generated! Review below, then click Create.', 'success');
  } catch(e) { setAiGenStatus('Failed: ' + e.message, 'error'); }
  finally { btn.classList.remove('btn-generating'); btn.textContent = 'Generate'; }
}

function setAiGenStatus(m, t) {
  const e = document.getElementById('aiGenStatus'); e.textContent = m; e.className = 'ai-gen-status' + (t ? ' '+t : '');
}

// ═══════════════════════════════════════
//  Settings
// ═══════════════════════════════════════
function openSettingsModal() {
  document.getElementById('globalPromptInput').value = state.globalSystemPrompt;
  document.getElementById('userCharNameInput').value = state.userCharacter.name;
  document.getElementById('userCharDescInput').value = state.userCharacter.description;
  // Set preset selector
  document.querySelectorAll('#presetSelector .preset-option').forEach(function(el) {
    el.classList.toggle('selected', el.dataset.preset === state.generationPreset);
  });
  document.getElementById('settingsModal').classList.add('active');
}
function closeSettingsModal() { document.getElementById('settingsModal').classList.remove('active'); }
function saveSettings() {
  state.globalSystemPrompt = document.getElementById('globalPromptInput').value.trim();
  localStorage.setItem('rpchat_global_prompt', state.globalSystemPrompt);
  // Save generation preset
  var selectedPreset = document.querySelector('#presetSelector .preset-option.selected');
  state.generationPreset = selectedPreset ? selectedPreset.dataset.preset : 'mid';
  localStorage.setItem('rpchat_generation_preset', state.generationPreset);
  state.userCharacter.name = document.getElementById('userCharNameInput').value.trim();
  state.userCharacter.description = document.getElementById('userCharDescInput').value.trim();
  saveUserCharacter();
  closeSettingsModal();
  renderMessages(); // refresh sender names
}

// ═══════════════════════════════════════
//  Multi-Character Helpers
// ═══════════════════════════════════════

function getActiveCharacters() {
  if (!state.activeCharId || !state.activeChatId) return [];
  const cc = getCharConvo(state.activeCharId);
  const chat = cc.chats[state.activeChatId];
  if (!chat) return [];
  if (!chat.activeCharacters || chat.activeCharacters.length === 0) {
    chat.activeCharacters = [state.activeCharId];
  }
  return chat.activeCharacters;
}

function fuzzyMatchCharacter(partial) {
  const lower = partial.toLowerCase();
  let match = state.characters.find(c => c.name.toLowerCase() === lower);
  if (match) return match;
  match = state.characters.find(c => c.name.toLowerCase().startsWith(lower));
  if (match) return match;
  match = state.characters.find(c => c.name.toLowerCase().includes(lower));
  return match || null;
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function parseInputCommand(text) {
  const trimmed = text.trim();
  // /u — standalone upload & summarize previous chat (check BEFORE /n /u)
  if (/^\/u(\s|$)/i.test(trimmed)) {
    return { type: 'uploadContext', contextTitle: null };
  }
  // /l "language" or /l "language" @CharName — set response language
  if (/^\/l\s/i.test(trimmed)) {
    var langMatch = trimmed.match(/^\/l\s+["']?([^"'@]+?)["']?\s*(?:@(\S+))?\s*$/i);
    if (langMatch) {
      var lang = langMatch[1].trim();
      var charPartial = langMatch[2] ? langMatch[2].trim() : null;
      var targetChar = charPartial ? fuzzyMatchCharacter(charPartial) : null;
      if (charPartial && !targetChar) return { type: 'error', message: 'No character found matching "' + charPartial + '"' };
      return { type: 'setLanguage', language: lang, targetChar: targetChar };
    }
    return { type: 'error', message: 'Usage: /l "language" or /l "language" @CharName' };
  }
  // /n /u "Title" — upload previous context with topic focus (must check BEFORE /n narration)
  if (/^\/n\s+\/u/i.test(trimmed)) {
    var titleMatch = trimmed.match(/^\/n\s+\/u\s+["'](.+?)["']\s*$/i);
    if (!titleMatch) titleMatch = trimmed.match(/^\/n\s+\/u\s+(.+)$/i);
    var contextTitle = titleMatch ? titleMatch[1].trim() : null;
    return { type: 'uploadContext', contextTitle: contextTitle };
  }
  if (trimmed.startsWith('/n ') || trimmed.startsWith('/N ')) {
    return { type: 'narration', content: trimmed.slice(3).trim() };
  }
  if (/^\+\S/.test(trimmed)) {
    const partial = trimmed.slice(1).trim();
    const match = fuzzyMatchCharacter(partial);
    if (match) return { type: 'addChar', char: match, raw: trimmed };
    return { type: 'error', message: 'No character found matching "' + partial + '"' };
  }
  if (/^-\S/.test(trimmed)) {
    const partial = trimmed.slice(1).trim();
    const match = fuzzyMatchCharacter(partial);
    if (match) return { type: 'removeChar', char: match, raw: trimmed };
    return { type: 'error', message: 'No character found matching "' + partial + '"' };
  }
  // Check for @ mentions — can be multiple: @Name (text) @Name2 (text)
  const atMatches = [];
  const atRegex = /@(\S+?)(?:\s*\(([^)]*)\))?(?=\s*@|\s*$)/g;
  let atTest = atRegex.exec(trimmed);
  while (atTest) {
    const match = fuzzyMatchCharacter(atTest[1]);
    if (match) atMatches.push({ char: match, instructions: (atTest[2] || '').trim() });
    atTest = atRegex.exec(trimmed);
  }
  if (atMatches.length > 0) {
    // Also capture any trailing text not in the @ pattern as general instructions
    const remaining = trimmed.replace(atRegex, '').trim();
    return { type: 'mention', mentions: atMatches, remaining: remaining, raw: trimmed };
  }
  return { type: 'message', content: trimmed };
}

function showSystemEvent(text) {
  const msgs = getActiveMessages();
  msgs.push({ role: 'system', content: text });
  saveConversations();
  renderMessages();
}

function renderActiveCharactersBar() {
  const bar = document.getElementById('activeCharsBar');
  if (!bar) return;
  bar.innerHTML = '';
  if (!state.activeCharId || !state.activeChatId) return;
  const activeIds = getActiveCharacters();
  if (activeIds.length <= 1) return; // hide bar for single-char chats
  activeIds.forEach(function(cid) {
    const ch = state.characters.find(function(c) { return c.id === cid; });
    if (!ch) return;
    const isPrimary = cid === state.activeCharId;
    const chip = document.createElement('div');
    chip.className = 'active-char-chip' + (isPrimary ? ' primary' : '');
    const avatarHtml = ch.avatarImage
      ? '<div class="chip-avatar"><img src="'+ch.avatarImage+'" alt=""></div>'
      : '<div class="chip-avatar" style="background:'+ch.color+'22;color:'+ch.color+'">'+ch.emoji+'</div>';
    let removeBtn = '';
    if (!isPrimary) {
      removeBtn = '<button class="chip-remove" onclick="event.stopPropagation();removeCharacterFromChat(\''+cid+'\')" title="Remove">&times;</button>';
    }
    chip.innerHTML = avatarHtml + '<span>' + escapeHtml(ch.name) + '</span>' + removeBtn;
    bar.appendChild(chip);
  });
}

function buildSystemPrompt(options) {
  options = options || {};
  var forcedCharIds = options.forcedCharIds;
  var isRemoval = options.isRemoval;
  var removingChar = options.removingChar;

  const activeIds = getActiveCharacters();
  const activeChars = activeIds.map(function(id) { return state.characters.find(function(c) { return c.id === id; }); }).filter(Boolean);
  const isMultiChar = activeChars.length > 1;

  const rpFormatRule = '\n\n[Formatting rules: Always wrap actions, thoughts, descriptions, and narration in *single asterisks* for italic styling. Dialogue should be in "double quotes" without asterisks. Keep dialogue as regular text. Example: *She looks up nervously* "Hello there." *her hands trembling slightly*]';

  var parts = [];

  if (state.globalSystemPrompt) parts.push(state.globalSystemPrompt);

  // Inject previous chat context if available
  var _ctxCC = state.activeCharId ? getCharConvo(state.activeCharId) : null;
  var _ctxChat = (_ctxCC && state.activeChatId) ? _ctxCC.chats[state.activeChatId] : null;
  if (_ctxChat && _ctxChat.previousContext) {
    var prevCtx = _ctxChat.previousContext;
    var ctxParts = ['[Previous Story Context]'];
    if (prevCtx.title) ctxParts.push('Focus: ' + prevCtx.title);
    ctxParts.push('Summary of previous events:\n' + prevCtx.summary);
    var activeCharNames = activeChars.map(function(c) { return c.name; });
    var memories = prevCtx.characterMemories || {};
    activeCharNames.forEach(function(name) {
      if (memories[name]) {
        ctxParts.push(name + '\'s memories from the previous session:\n' + memories[name]);
      }
    });
    ctxParts.push('Use this context to inform character responses. Characters should naturally recall past events when relevant, without forcing references into every response.');
    parts.push(ctxParts.join('\n'));
  }

  if (state.userCharacter.name || state.userCharacter.description) {
    var userSection = '[User Character]\n';
    if (state.userCharacter.name) userSection += 'The user\'s name/persona is: ' + state.userCharacter.name + '.\n';
    if (state.userCharacter.description) userSection += 'Description: ' + state.userCharacter.description + '\n';
    userSection += 'Address the user by this persona. The user\'s messages come from this character.';
    parts.push(userSection);
  }

  // Inject language instructions
  if (_ctxChat) {
    var langParts = [];
    if (_ctxChat.language) {
      langParts.push('[Language Instruction]\nAll characters MUST respond in ' + _ctxChat.language + '. This applies to all dialogue, narration, and actions.');
    }
    if (_ctxChat.characterLanguages) {
      Object.keys(_ctxChat.characterLanguages).forEach(function(charName) {
        langParts.push(charName + ' MUST respond in ' + _ctxChat.characterLanguages[charName] + '.');
      });
    }
    if (langParts.length > 0) parts.push(langParts.join('\n'));
  }

  if (isMultiChar) {
    parts.push('[Multi-Character Scene]\nThis is a multi-character roleplay. The following characters are present in this scene:\n');
    activeChars.forEach(function(ch) {
      parts.push('--- ' + ch.name + ' ---\n' + ch.prompt);
    });
    parts.push(
      '\n[Multi-Character Response Rules]\n' +
      '- IMPORTANT: Each character\'s response MUST start on a new line with their name in this exact format: [CharacterFullName]: followed by their response.\n' +
      '- Multiple characters can respond to a single user message. Separate each character\'s block with a blank line.\n' +
      '- Only characters who would naturally respond in context should speak. Not every character must respond every time.\n' +
      '- Stay in character for each. Different characters have different speech patterns, knowledge, and personalities.\n' +
      '- Example format:\n' +
      '[' + activeChars[0].name + ']: *strokes beard thoughtfully* "That is an interesting question."\n\n' +
      (activeChars[1] ? '[' + activeChars[1].name + ']: *laughs from the corner* "What he means is, you\'re in over your head."' : '')
    );

    if (forcedCharIds && forcedCharIds.length > 0) {
      var forcedNames = forcedCharIds.map(function(id) {
        var c = state.characters.find(function(ch) { return ch.id === id; });
        return c ? c.name : null;
      }).filter(Boolean);
      if (forcedNames.length > 0) {
        parts.push('\n[IMPORTANT: The user has specifically directed ' + forcedNames.join(' and ') + ' to respond. Make sure ' + (forcedNames.length === 1 ? 'this character responds' : 'these characters respond') + '.]');
      }
    }

    if (isRemoval && removingChar) {
      parts.push('\n[IMPORTANT: ' + removingChar.name + ' is leaving the scene. Write a brief, in-character exit for ' + removingChar.name + '. Other present characters may react briefly.]');
    }
  } else {
    parts.push(activeChars[0] ? activeChars[0].prompt : '');
  }

  parts.push(rpFormatRule);
  return parts.join('\n\n');
}

function buildApiMessages(msgs) {
  var apiMsgs = [];
  msgs.forEach(function(m) {
    if (m.role === 'system') return; // skip join/leave events from API context
    if (m.isNarration) {
      apiMsgs.push({ role: 'system', content: '[Narration]: ' + m.content });
    } else if (m.charId && m.role === 'assistant') {
      apiMsgs.push({ role: 'assistant', content: '[' + (m.charName || 'Unknown') + ']: ' + m.content });
    } else {
      apiMsgs.push({ role: m.role, content: m.content });
    }
  });
  return apiMsgs;
}

function parseMultiCharResponse(responseText, activeCharIds) {
  var activeChars = activeCharIds.map(function(id) { return state.characters.find(function(c) { return c.id === id; }); }).filter(Boolean);

  if (activeChars.length <= 1) {
    return [{ charId: activeChars[0] ? activeChars[0].id : null, charName: activeChars[0] ? activeChars[0].name : null, content: responseText.trim() }];
  }

  var charNames = activeChars.map(function(c) { return c.name; });
  var namePattern = charNames.map(escapeRegExp).join('|');
  var regex = new RegExp('^\\s*\\[?(' + namePattern + ')\\]?\\s*:', 'gmi');

  var splits = [];
  var lastChar = null;
  var lastIndex = 0;
  var match;

  while ((match = regex.exec(responseText)) !== null) {
    if (lastChar !== null) {
      splits.push({ charName: lastChar, content: responseText.slice(lastIndex, match.index).trim() });
    }
    lastChar = match[1];
    lastIndex = match.index + match[0].length;
  }
  if (lastChar !== null) {
    splits.push({ charName: lastChar, content: responseText.slice(lastIndex).trim() });
  }

  if (splits.length > 0) {
    return splits.map(function(s) {
      var ch = activeChars.find(function(c) { return c.name.toLowerCase() === s.charName.toLowerCase(); });
      return { charId: ch ? ch.id : null, charName: s.charName, content: s.content };
    });
  }

  return [{ charId: activeChars[0].id, charName: activeChars[0].name, content: responseText.trim() }];
}

function addCharacterToChat(char) {
  if (!state.activeChatId || !state.activeCharId) return;
  var cc = getCharConvo(state.activeCharId);
  var chat = cc.chats[state.activeChatId];
  if (!chat) return;
  if (!chat.activeCharacters) chat.activeCharacters = [state.activeCharId];
  if (chat.activeCharacters.includes(char.id)) {
    showSystemEvent(char.name + ' is already in this conversation.');
    return;
  }
  chat.activeCharacters.push(char.id);
  var msgs = getActiveMessages();
  // Include character-specific memory from previous context if available
  if (chat.previousContext && chat.previousContext.characterMemories && chat.previousContext.characterMemories[char.name]) {
    msgs.push({ role: 'system', content: char.name + ' has joined the conversation. (Carries memories from: ' + (chat.previousContext.sourceChat ? chat.previousContext.sourceChat.title : 'previous chat') + ')' });
  } else {
    msgs.push({ role: 'system', content: char.name + ' has joined the conversation.' });
  }
  saveConversations(); renderMessages(); renderActiveCharactersBar();
}

function removeCharacterFromChat(charId) {
  var ch = state.characters.find(function(c) { return c.id === charId; });
  if (ch) removeCharacterFromChatWithExit(ch);
}

async function removeCharacterFromChatWithExit(char) {
  if (!state.activeChatId || !state.activeCharId) return;
  var cc = getCharConvo(state.activeCharId);
  var chat = cc.chats[state.activeChatId];
  if (!chat || !chat.activeCharacters) return;
  if (!chat.activeCharacters.includes(char.id)) {
    showSystemEvent(char.name + ' is not in this conversation.');
    return;
  }
  if (char.id === state.activeCharId) {
    showSystemEvent('Cannot remove the primary character.');
    return;
  }

  var msgs = getActiveMessages();
  var sysContent = buildSystemPrompt({ isRemoval: true, removingChar: char });
  var apiMsgs = [{ role: 'system', content: sysContent }].concat(buildApiMessages(msgs));
  apiMsgs.push({ role: 'user', content: '[' + char.name + ' is leaving the scene. Write their brief in-character exit.]' });

  state.isStreaming = true;
  document.getElementById('sendBtn').disabled = true;
  document.getElementById('typingIndicator').classList.add('active');

  try {
    var resp = await fetch(OPENROUTER_API_BASE + '/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + state.apiKey, 'Content-Type': 'application/json', 'HTTP-Referer': CALLBACK_URL, 'X-Title': APP_NAME },
      body: JSON.stringify(Object.assign({ model: document.getElementById('modelSelect').value, messages: apiMsgs, stream: false, max_tokens: 512 }, getGenerationParams()))
    });
    if (!resp.ok) throw new Error('API error ' + resp.status);
    var d = await resp.json();
    var exitContent = d.choices && d.choices[0] && d.choices[0].message ? d.choices[0].message.content : '*' + char.name + ' exits quietly.*';
    // Strip the [CharName]: prefix if present
    exitContent = exitContent.replace(new RegExp('^\\s*\\[?' + escapeRegExp(char.name) + '\\]?\\s*:', 'i'), '').trim();
    msgs.push({ role: 'assistant', content: exitContent, charId: char.id, charName: char.name });
  } catch(e) {
    msgs.push({ role: 'assistant', content: '*' + char.name + ' leaves the scene.*', charId: char.id, charName: char.name });
  } finally {
    state.isStreaming = false;
    document.getElementById('sendBtn').disabled = false;
    document.getElementById('typingIndicator').classList.remove('active');
  }

  chat.activeCharacters = chat.activeCharacters.filter(function(id) { return id !== char.id; });
  msgs.push({ role: 'system', content: char.name + ' has left the conversation.' });
  saveConversations(); renderMessages(); renderActiveCharactersBar();
}

function updateCommandHint(text) {
  var hint = document.getElementById('commandHint');
  if (!hint) return;
  var trimmed = text.trim();

  // Hide hint when user is typing /l, /u, or /n content (not just "/" alone)
  if (/^\/(l|u)\S*/i.test(trimmed) && trimmed.length > 1) {
    hint.classList.remove('visible'); hint.innerHTML = ''; return;
  }
  if (/^\/n\s/i.test(trimmed)) {
    hint.classList.remove('visible'); hint.innerHTML = ''; return;
  }

  // "/" or just "/" — context-aware command menu
  if (trimmed === '/') {
    var activeCharIds = getActiveCharacters();
    var removableCount = activeCharIds.length > 1 ? activeCharIds.filter(function(id) { return id !== state.activeCharId; }).length : 0;
    var addableCount = state.characters.filter(function(c) { return activeCharIds.indexOf(c.id) === -1; }).length;
    var msgs = getActiveMessages();
    var hasUserMessages = msgs.some(function(m) { return m.role === 'user'; });

    var items = '';
    items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'/n\')">' +
      '<span class="command-hint-cmd">/n</span><span class="command-hint-desc">Narrate an action or scene</span></div>';
    if (!hasUserMessages) {
      items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'/u\')">' +
        '<span class="command-hint-cmd">/u</span><span class="command-hint-desc">Load & summarize a previous chat</span></div>';
    }
    items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'/l\')">' +
      '<span class="command-hint-cmd">/l</span><span class="command-hint-desc">Set response language</span></div>';
    if (addableCount > 0) {
      items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'+\')">' +
        '<span class="command-hint-cmd">+</span><span class="command-hint-desc">Add a character to this chat</span></div>';
    }
    if (removableCount > 0) {
      items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'-\')">' +
        '<span class="command-hint-cmd">\u2212</span><span class="command-hint-desc">Remove a character from this chat</span></div>';
    }
    items += '<div class="command-hint-item" onclick="applyCommandHint(\'command\',\'@\')">' +
      '<span class="command-hint-cmd">@</span><span class="command-hint-desc">Direct a character to respond</span></div>';

    hint.innerHTML = items;
    hint.classList.add('visible');
    return;
  }

  // Character list modes: +, -, @
  var prefix = null, partial = '';
  if (/^\+/.test(trimmed)) { prefix = '+'; partial = trimmed.slice(1).trim(); }
  else if (/^-/.test(trimmed)) { prefix = '-'; partial = trimmed.slice(1).trim(); }
  else if (/^@/.test(trimmed)) { prefix = '@'; partial = trimmed.slice(1).trim(); }

  if (!prefix) { hint.classList.remove('visible'); hint.innerHTML = ''; return; }

  var activeCharIds = getActiveCharacters();
  var candidates = [];

  if (prefix === '+') {
    // Show only characters NOT in the chat
    candidates = state.characters.filter(function(c) {
      return activeCharIds.indexOf(c.id) === -1;
    });
  } else if (prefix === '-') {
    // Show only characters IN the chat, excluding primary
    candidates = state.characters.filter(function(c) {
      return c.id !== state.activeCharId && activeCharIds.indexOf(c.id) !== -1;
    });
  } else if (prefix === '@') {
    // Show only characters IN the chat
    candidates = state.characters.filter(function(c) {
      return activeCharIds.indexOf(c.id) !== -1;
    });
  }

  // Apply fuzzy filter if partial name typed
  if (partial) {
    var lower = partial.toLowerCase();
    candidates = candidates.filter(function(c) {
      return c.name.toLowerCase().startsWith(lower) || c.name.toLowerCase().includes(lower);
    });
  }

  candidates = candidates.slice(0, 8);

  if (candidates.length === 0) {
    var emptyMsg = prefix === '+' ? 'No more characters to add' :
                   prefix === '-' ? 'No characters to remove' :
                   'No matching characters';
    hint.innerHTML = '<div class="command-hint-empty">' + emptyMsg + '</div>';
    hint.classList.add('visible');
    return;
  }

  hint.innerHTML = candidates.map(function(ch) {
    var avatarHtml = ch.avatarImage
      ? '<img src="'+ch.avatarImage+'" style="width:24px;height:24px;border-radius:50%;object-fit:cover;" alt="">'
      : '<span style="font-size:18px;color:'+ch.color+'">'+ch.emoji+'</span>';
    var safeName = ch.name.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
    return '<div class="command-hint-item" onclick="applyCharHint(\''+prefix+'\',\''+safeName+'\')">' +
      avatarHtml + '<span>' + escapeHtml(ch.name) + '</span></div>';
  }).join('');
  hint.classList.add('visible');
}

function applyCommandHint(type, value) {
  var input = document.getElementById('userInput');
  var hint = document.getElementById('commandHint');
  if (value === '/n') { input.value = '/n '; hint.classList.remove('visible'); }
  else if (value === '/u') { input.value = '/u'; hint.classList.remove('visible'); }
  else if (value === '/l') { input.value = '/l "'; hint.classList.remove('visible'); }
  else {
    // +, -, @ — set prefix and show character list
    input.value = value;
    updateCommandHint(value);
  }
  input.focus();
}

function applyCharHint(prefix, charName) {
  var input = document.getElementById('userInput');
  if (prefix === '@') { input.value = '@' + charName + ' '; }
  else { input.value = prefix + charName; }
  document.getElementById('commandHint').classList.remove('visible');
  input.focus();
}

// ═══════════════════════════════════════
//  Chat / API
// ═══════════════════════════════════════
function handleInputKey(e) {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
  if (e.key === 'Escape') { var h = document.getElementById('commandHint'); if (h) h.classList.remove('visible'); }
}

async function sendMessage() {
  if (state.isStreaming || !state.activeCharId || !state.activeChatId) return;
  var input = document.getElementById('userInput');
  var text = input.value.trim(); if (!text) return;

  // Hide command hint
  var hint = document.getElementById('commandHint');
  if (hint) hint.classList.remove('visible');

  var cmd = parseInputCommand(text);
  input.value = ''; input.style.height = 'auto';

  // Handle error
  if (cmd.type === 'error') { showSystemEvent(cmd.message); return; }

  // Handle /n /u (upload previous context)
  if (cmd.type === 'uploadContext') {
    var msgs = getActiveMessages();
    var realMsgCount = msgs.filter(function(m) { return m.role === 'user'; }).length;
    if (realMsgCount > 0) {
      showSystemEvent('Context upload must be done at the start of a new chat. Please create a new chat first.');
      return;
    }
    openUploadContextModal(cmd.contextTitle);
    return;
  }

  // Handle /l (set language)
  if (cmd.type === 'setLanguage') {
    var cc = getCharConvo(state.activeCharId);
    var chat = cc.chats[state.activeChatId];
    if (cmd.targetChar) {
      if (!chat.characterLanguages) chat.characterLanguages = {};
      chat.characterLanguages[cmd.targetChar.name] = cmd.language;
      showSystemEvent(cmd.targetChar.name + ' will now respond in ' + cmd.language + '.');
    } else {
      chat.language = cmd.language;
      showSystemEvent('All characters will now respond in ' + cmd.language + '.');
    }
    saveConversations();
    return;
  }

  // Handle narration /n
  if (cmd.type === 'narration') {
    var msgs = getActiveMessages();
    msgs.push({ role: 'assistant', content: cmd.content, isNarration: true });
    saveConversations(); renderMessages(); return;
  }

  // Handle +Character
  if (cmd.type === 'addChar') { addCharacterToChat(cmd.char); return; }

  // Handle -Character
  if (cmd.type === 'removeChar') { await removeCharacterFromChatWithExit(cmd.char); return; }

  // Handle @mention or regular message
  var msgs = getActiveMessages();
  var ch = state.characters.find(function(c) { return c.id === state.activeCharId; });
  var forcedCharIds = null;

  if (cmd.type === 'mention') {
    forcedCharIds = cmd.mentions.map(function(m) { return m.char.id; });
    msgs.push({ role: 'user', content: text });
  } else {
    msgs.push({ role: 'user', content: text });
  }

  // Auto-title
  var cc = getCharConvo(state.activeCharId);
  var chat = cc.chats[state.activeChatId];
  if (chat && chat.title === 'New Conversation') {
    chat.title = text.length > 35 ? text.substring(0, 35) + '...' : text;
    renderChatHistory();
  }

  renderMessages(); saveConversations();

  var sysContent = buildSystemPrompt({ forcedCharIds: forcedCharIds });
  var apiMessages = [{ role: 'system', content: sysContent }].concat(buildApiMessages(msgs));

  state.isStreaming = true;
  document.getElementById('sendBtn').disabled = true;
  document.getElementById('typingIndicator').classList.add('active');

  try {
    var resp = await fetch(OPENROUTER_API_BASE + '/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': 'Bearer ' + state.apiKey, 'Content-Type': 'application/json', 'HTTP-Referer': CALLBACK_URL, 'X-Title': APP_NAME },
      body: JSON.stringify(Object.assign({ model: document.getElementById('modelSelect').value, messages: apiMessages, stream: true, max_tokens: 2048 }, getGenerationParams()))
    });
    if (!resp.ok) { var et = await resp.text(); throw new Error('API error ' + resp.status + ': ' + et); }

    var reader = resp.body.getReader();
    var decoder = new TextDecoder();
    var fullResponse = '', buffer = '';
    msgs.push({ role: 'assistant', content: '' });
    var tempIdx = msgs.length - 1;
    document.getElementById('typingIndicator').classList.remove('active');
    renderMessages();

    while (true) {
      var chunk = await reader.read();
      if (chunk.done) break;
      buffer += decoder.decode(chunk.value, { stream: true });
      var lines = buffer.split('\n'); buffer = lines.pop() || '';
      for (var i = 0; i < lines.length; i++) {
        var tr = lines[i].trim();
        if (!tr || !tr.startsWith('data: ')) continue;
        var data = tr.slice(6); if (data === '[DONE]') continue;
        try {
          var p = JSON.parse(data);
          var delta = p.choices && p.choices[0] && p.choices[0].delta ? p.choices[0].delta.content : null;
          if (delta) { fullResponse += delta; msgs[tempIdx].content = fullResponse; updateStreamingContent(fullResponse); }
        } catch(e) {}
      }
    }

    // Post-stream: parse multi-character responses
    var activeIds = getActiveCharacters();
    if (activeIds.length > 1) {
      var parsed = parseMultiCharResponse(fullResponse, activeIds);
      msgs.splice(tempIdx, 1); // remove temp streaming message
      parsed.forEach(function(block) {
        msgs.push({ role: 'assistant', content: block.content, charId: block.charId, charName: block.charName });
      });
    } else {
      msgs[tempIdx].charId = state.activeCharId;
      msgs[tempIdx].charName = ch ? ch.name : null;
    }

    saveConversations(); renderMessages();
  } catch(err) {
    document.getElementById('typingIndicator').classList.remove('active');
    var ms = getActiveMessages();
    if (ms.length && ms[ms.length-1].role === 'assistant' && !ms[ms.length-1].content) ms.pop();
    var ed = document.createElement('div'); ed.className = 'message assistant';
    ed.innerHTML = '<div class="sender" style="color:var(--danger)">Error</div><div class="content" style="color:var(--danger)">' + escapeHtml(err.message) + '</div>';
    document.getElementById('messages').appendChild(ed);
    scrollToBottom();
  } finally {
    state.isStreaming = false; document.getElementById('sendBtn').disabled = false;
  }
}

function clearChat() {
  if (!state.activeCharId || !state.activeChatId) return;
  if (!confirm('Clear this conversation?')) return;
  var ch = state.characters.find(function(c) { return c.id === state.activeCharId; });
  var msgs = [];
  if (ch && ch.greeting) msgs.push({ role: 'assistant', content: ch.greeting, charId: ch.id, charName: ch.name });
  setActiveMessages(msgs);
  var cc = getCharConvo(state.activeCharId);
  if (cc.chats[state.activeChatId]) {
    cc.chats[state.activeChatId].title = 'New Conversation';
    cc.chats[state.activeChatId].activeCharacters = [state.activeCharId];
  }
  saveConversations(); renderMessages(); renderChatHistory(); renderActiveCharactersBar();
}

function toggleSidebar() {
  const s = document.getElementById('sidebar'); s.classList.toggle('open'); s.classList.toggle('collapsed');
}

// ─── Auto-resize textarea ───
document.addEventListener('DOMContentLoaded', () => {
  const ta = document.getElementById('userInput');
  if (ta) ta.addEventListener('input', () => { ta.style.height = 'auto'; ta.style.height = Math.min(ta.scrollHeight, 150) + 'px'; updateCommandHint(ta.value); });
});

// ═══════════════════════════════════════
//  Context Menus
// ═══════════════════════════════════════
let activeContextMenu = null;

function closeContextMenu() {
  if (activeContextMenu) { activeContextMenu.remove(); activeContextMenu = null; }
  document.removeEventListener('click', closeContextMenu);
}

function showContextMenu(x, y, items) {
  closeContextMenu();
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  items.forEach(item => {
    if (item === 'sep') {
      const sep = document.createElement('div'); sep.className = 'context-menu-sep'; menu.appendChild(sep); return;
    }
    const btn = document.createElement('button');
    btn.className = 'context-menu-item' + (item.danger ? ' danger' : '');
    btn.innerHTML = item.icon + ' ' + item.label;
    btn.onclick = (e) => { e.stopPropagation(); closeContextMenu(); item.action(); };
    menu.appendChild(btn);
  });
  document.body.appendChild(menu);
  const rect = menu.getBoundingClientRect();
  let left = x, top = y;
  if (left + rect.width > window.innerWidth) left = window.innerWidth - rect.width - 8;
  if (top + rect.height > window.innerHeight) top = window.innerHeight - rect.height - 8;
  if (left < 8) left = 8;
  if (top < 8) top = 8;
  menu.style.left = left + 'px';
  menu.style.top = top + 'px';
  activeContextMenu = menu;
  setTimeout(() => document.addEventListener('click', closeContextMenu), 0);
}

function openCharContextMenu(event, charId) {
  event.stopPropagation();
  const rect = event.currentTarget.getBoundingClientRect();
  showContextMenu(rect.left, rect.bottom + 4, [
    { icon: '&#9998;', label: 'Edit', action: () => editCharacter(charId) },
    { icon: '&#8615;', label: 'Export', action: () => openExportCharModal(charId) },
    'sep',
    { icon: '&#10005;', label: 'Delete', danger: true, action: () => deleteCharacter(charId) }
  ]);
}

function openChatContextMenu(event, chatId) {
  event.stopPropagation();
  const rect = event.currentTarget.getBoundingClientRect();
  showContextMenu(rect.left, rect.bottom + 4, [
    { icon: '&#8615;', label: 'Export Chat', action: () => exportChat(chatId) },
    'sep',
    { icon: '&#10005;', label: 'Delete', danger: true, action: () => deleteThisChat(chatId) }
  ]);
}

// ═══════════════════════════════════════
//  Export / Import
// ═══════════════════════════════════════
let exportingCharId = null;

function downloadJson(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

function sanitizeFilename(name) {
  return name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').substring(0, 40);
}

// ─── Export Character ───
function openExportCharModal(charId) {
  exportingCharId = charId;
  const ch = state.characters.find(c => c.id === charId); if (!ch) return;
  document.getElementById('exportCharDesc').textContent = 'Export "' + ch.name + '" as a JSON file.';
  document.getElementById('exportIncludeChats').checked = true;
  document.getElementById('exportCharModal').classList.add('active');
}
function closeExportCharModal() {
  document.getElementById('exportCharModal').classList.remove('active'); exportingCharId = null;
}

function exportCharacterFromEdit() {
  if (state.editingCharId) { const id = state.editingCharId; closeCharModal(); openExportCharModal(id); }
}

function executeCharExport() {
  const ch = state.characters.find(c => c.id === exportingCharId); if (!ch) return;
  const includeChats = document.getElementById('exportIncludeChats').checked;
  const exportData = {
    _type: 'rpchat_character', _version: 1, _exportedAt: new Date().toISOString(),
    character: { name: ch.name, tagline: ch.tagline, emoji: ch.emoji, color: ch.color,
      prompt: ch.prompt, greeting: ch.greeting || '', avatarImage: ch.avatarImage || null }
  };
  if (includeChats) {
    const cc = state.conversations[exportingCharId];
    if (cc && cc.chats) {
      exportData.chats = Object.values(cc.chats).map(chat => ({
        title: chat.title, created: chat.created, messages: chat.messages
      }));
    }
  }
  downloadJson(exportData, 'rpchat-char-' + sanitizeFilename(ch.name) + '.json');
  closeExportCharModal();
}

// ─── Export Chat ───
function exportChat(chatId) {
  if (!state.activeCharId) return;
  const cc = getCharConvo(state.activeCharId);
  const chat = cc.chats[chatId]; if (!chat) return;
  const ch = state.characters.find(c => c.id === state.activeCharId);
  const exportData = {
    _type: 'rpchat_chat', _version: 1, _exportedAt: new Date().toISOString(),
    characterName: ch ? ch.name : 'Unknown',
    chat: { title: chat.title, created: chat.created, messages: chat.messages }
  };
  if (chat.previousContext) exportData.chat.previousContext = chat.previousContext;
  downloadJson(exportData, 'rpchat-chat-' + sanitizeFilename(chat.title || 'conversation') + '.json');
}

// ─── Import Character ───
function openImportCharModal() {
  document.getElementById('importCharFileInput').value = '';
  document.getElementById('importCharStatus').textContent = '';
  document.getElementById('importCharModal').classList.add('active');
}
function closeImportCharModal() { document.getElementById('importCharModal').classList.remove('active'); }

function handleImportCharFile(event) {
  const file = event.target.files[0]; if (!file) return;
  const status = document.getElementById('importCharStatus');
  status.textContent = 'Reading file...'; status.style.color = 'var(--text-secondary)';
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      if (data._type !== 'rpchat_character' || !data.character || !data.character.name)
        throw new Error('Not a valid RPChat character file.');
      const c = data.character;
      const newId = 'char_' + Date.now();
      let name = c.name;
      if (state.characters.some(ch => ch.name === name)) name += ' (imported)';
      const newChar = { id: newId, name, tagline: c.tagline || name, emoji: c.emoji || AVATARS[0],
        color: c.color || '#7c5cff', prompt: c.prompt || '', greeting: c.greeting || '',
        avatarImage: c.avatarImage || null };
      state.characters.push(newChar);
      let chatCount = 0;
      if (data.chats && Array.isArray(data.chats) && data.chats.length > 0) {
        const convo = getCharConvo(newId);
        data.chats.forEach(chat => {
          const chatId = 'chat_' + Date.now() + '_' + Math.random().toString(36).slice(2,6);
          convo.chats[chatId] = { id: chatId, title: chat.title || 'Imported Chat',
            created: chat.created || Date.now(), messages: chat.messages || [] };
          if (!convo.activeChat) convo.activeChat = chatId;
        });
        chatCount = data.chats.length;
        saveConversations();
      }
      saveCharacters(); renderCharList();
      status.textContent = 'Imported "' + newChar.name + '"' + (chatCount ? ' with ' + chatCount + ' chat(s)' : '') + '.';
      status.style.color = 'var(--success)';
    } catch(err) { status.textContent = 'Error: ' + err.message; status.style.color = 'var(--danger)'; }
  };
  reader.onerror = () => { status.textContent = 'Error reading file.'; status.style.color = 'var(--danger)'; };
  reader.readAsText(file);
}

// ─── Import Chat ───
function openImportChatModal() {
  if (!state.activeCharId) { alert('Please select a character first.'); return; }
  document.getElementById('importChatFileInput').value = '';
  document.getElementById('importChatStatus').textContent = '';
  document.getElementById('importChatModal').classList.add('active');
}
function closeImportChatModal() { document.getElementById('importChatModal').classList.remove('active'); }

function handleImportChatFile(event) {
  const file = event.target.files[0]; if (!file) return;
  const status = document.getElementById('importChatStatus');
  status.textContent = 'Reading file...'; status.style.color = 'var(--text-secondary)';
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      if (data._type !== 'rpchat_chat' || !data.chat || !data.chat.messages)
        throw new Error('Not a valid RPChat chat file.');
      const cc = getCharConvo(state.activeCharId);
      const chatId = 'chat_' + Date.now() + '_' + Math.random().toString(36).slice(2,6);
      cc.chats[chatId] = { id: chatId, title: data.chat.title || 'Imported Chat',
        created: data.chat.created || Date.now(), messages: data.chat.messages,
        previousContext: data.chat.previousContext || null };
      cc.activeChat = chatId; state.activeChatId = chatId;
      saveConversations(); renderMessages(); renderChatHistory();
      status.textContent = 'Imported "' + (data.chat.title || 'chat') + '" with ' + data.chat.messages.length + ' messages.';
      status.style.color = 'var(--success)';
    } catch(err) { status.textContent = 'Error: ' + err.message; status.style.color = 'var(--danger)'; }
  };
  reader.onerror = () => { status.textContent = 'Error reading file.'; status.style.color = 'var(--danger)'; };
  reader.readAsText(file);
}

// ─── Upload Context (Chat Continuity) ───
function openUploadContextModal(presetTitle) {
  document.getElementById('uploadContextFileInput').value = '';
  document.getElementById('uploadContextStatus').textContent = '';
  document.getElementById('contextTitleInput').value = presetTitle || '';
  document.getElementById('uploadContextModal').classList.add('active');
}
function closeUploadContextModal() { document.getElementById('uploadContextModal').classList.remove('active'); }

async function handleUploadContextFile(event) {
  var file = event.target.files[0]; if (!file) return;
  var status = document.getElementById('uploadContextStatus');
  var chooseBtn = document.getElementById('uploadContextChooseBtn');
  status.textContent = 'Reading file...'; status.style.color = 'var(--text-secondary)';

  var reader = new FileReader();
  reader.onload = async function(e) {
    try {
      var data = JSON.parse(e.target.result);
      if (data._type !== 'rpchat_chat' || !data.chat || !data.chat.messages)
        throw new Error('Not a valid RPChat chat export file.');
      if (!state.apiKey) throw new Error('Please connect to OpenRouter first.');

      var contextTitle = document.getElementById('contextTitleInput').value.trim();
      var sourceMsgs = data.chat.messages;
      var sourceTitle = data.chat.title || 'Unknown Chat';
      if (sourceMsgs.length === 0) throw new Error('The uploaded chat has no messages.');

      chooseBtn.disabled = true;
      status.innerHTML = '<span style="color:var(--accent)">&#9881; Analyzing chat with AI... This may take a moment.</span>';

      var previousContext = await summarizePreviousChat(sourceMsgs, contextTitle, sourceTitle);

      var cc = getCharConvo(state.activeCharId);
      var chat = cc.chats[state.activeChatId];
      if (chat) { chat.previousContext = previousContext; saveConversations(); }

      closeUploadContextModal();
      renderMessages();
      showSystemEvent('Previous context loaded: ' + (previousContext.title || 'General Summary') + ' (' + previousContext.sourceChat.messageCount + ' messages analyzed)');
    } catch(err) {
      status.textContent = 'Error: ' + err.message; status.style.color = 'var(--danger)';
    } finally { chooseBtn.disabled = false; }
  };
  reader.onerror = function() { status.textContent = 'Error reading file.'; status.style.color = 'var(--danger)'; };
  reader.readAsText(file);
}

async function summarizePreviousChat(messages, contextTitle, sourceChatTitle) {
  var transcript = messages.map(function(m) {
    if (m.role === 'system') return '[System: ' + m.content + ']';
    if (m.isNarration) return '[Narration: ' + m.content + ']';
    var name = m.charName || (m.role === 'user' ? (state.userCharacter.name || 'User') : 'AI');
    return name + ': ' + m.content;
  }).join('\n');

  var maxLen = 30000;
  if (transcript.length > maxLen) {
    transcript = transcript.slice(0, maxLen) + '\n\n[...transcript truncated for length...]';
  }

  var charNames = [];
  messages.forEach(function(m) {
    if (m.charName && charNames.indexOf(m.charName) === -1) charNames.push(m.charName);
  });

  var focusInstruction = contextTitle
    ? 'Focus your summary specifically on events, details, and character knowledge related to: "' + contextTitle + '". Prioritize information relevant to this topic.'
    : 'Create a general summary covering all major events, revelations, and character developments.';

  var summaryPrompt = 'You are a story analyst. Analyze the following roleplay chat transcript and produce a structured summary.\n\n' +
    focusInstruction + '\n\n' +
    'You MUST respond with valid JSON only, no markdown code fences. Use exactly this format:\n' +
    '{"summary":"A 2-4 paragraph summary of the story so far, key events, and current situation.","characterMemories":{"CharName":"What this character knows, experienced, their emotional state, and important details they would remember.",...(one entry per character)}}\n\n' +
    'Characters that appeared: ' + (charNames.length > 0 ? charNames.join(', ') : 'Unknown') + '\n\n' +
    'Chat title: "' + sourceChatTitle + '"\n\nChat transcript:\n' + transcript;

  var resp = await fetch(OPENROUTER_API_BASE + '/chat/completions', {
    method: 'POST',
    headers: { 'Authorization': 'Bearer ' + state.apiKey, 'Content-Type': 'application/json', 'HTTP-Referer': CALLBACK_URL, 'X-Title': APP_NAME },
    body: JSON.stringify({
      model: document.getElementById('modelSelect').value,
      messages: [
        { role: 'system', content: 'You are a precise story analyst. Always respond with valid JSON only, no markdown formatting or code fences.' },
        { role: 'user', content: summaryPrompt }
      ],
      stream: false, temperature: 0.3, max_tokens: 2048
    })
  });

  if (!resp.ok) throw new Error('API error ' + resp.status + ' while summarizing chat.');
  var d = await resp.json();
  var responseText = d.choices && d.choices[0] && d.choices[0].message ? d.choices[0].message.content : null;
  if (!responseText) throw new Error('Empty response from AI summarization.');

  var cleanJson = responseText.replace(/^```json?\s*/i, '').replace(/```\s*$/, '').trim();
  // Strip <think>...</think> blocks
  cleanJson = cleanJson.replace(/<think>[\s\S]*?<\/think>/gi, '').trim();
  var parsed;
  try { parsed = JSON.parse(cleanJson); }
  catch(e) { parsed = { summary: responseText, characterMemories: {} }; }

  return {
    title: contextTitle || null,
    summary: parsed.summary || responseText,
    characterMemories: parsed.characterMemories || {},
    sourceChat: { title: sourceChatTitle, messageCount: messages.length }
  };
}

function toggleContextBanner(headerEl) {
  var body = headerEl.nextElementSibling;
  var arrow = headerEl.querySelector('.context-banner-toggle');
  body.classList.toggle('open');
  arrow.innerHTML = body.classList.contains('open') ? '&#9650;' : '&#9660;';
}

// ─── Modal close handlers ───
document.getElementById('charModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeCharModal(); });
document.getElementById('settingsModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeSettingsModal(); });
document.getElementById('exportCharModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeExportCharModal(); });
document.getElementById('importCharModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeImportCharModal(); });
document.getElementById('importChatModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeImportChatModal(); });
document.getElementById('uploadContextModal').addEventListener('click', e => { if (e.target === e.currentTarget) closeUploadContextModal(); });
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') { closeCharModal(); closeSettingsModal(); closeExportCharModal(); closeImportCharModal(); closeImportChatModal(); closeUploadContextModal(); closeContextMenu(); }
});

// ─── Init ───
init();
</script>
</body>
</html>
